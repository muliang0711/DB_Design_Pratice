CREATE OR REPLACE PROCEDURE GEN_BUS_SCHEDULES (
  p_rda_id   IN routeDriverAssignmentList.routeDriverAssignmentId%TYPE,
  p_max_days IN NUMBER DEFAULT 90
) IS
  --------------------------------------------------------------------
  -- RDA fields
  --------------------------------------------------------------------
  v_route_id      route.routeId%TYPE;
  v_assignment_id routeDriverAssignmentList.assignmentId%TYPE;
  v_freq          routeDriverAssignmentList.frequency%TYPE;
  v_weekdays      routeDriverAssignmentList.weekdays%TYPE;
  v_eff_from      DATE;
  v_eff_to        DATE;
  v_status        routeDriverAssignmentList.status%TYPE;

  --------------------------------------------------------------------
  -- Route fields
  --------------------------------------------------------------------
  v_dep_hhmm     route.plannedDepartureTime%TYPE;
  v_arr_hhmm     route.plannedArrivalTime%TYPE;
  v_est_min      route.estimatedDuration%TYPE;
  v_distance_km  route.distanceKm%TYPE;

  --------------------------------------------------------------------
  -- Working vars
  --------------------------------------------------------------------
  v_start_date   DATE;
  v_end_date     DATE;
  v_dep_ts       TIMESTAMP;
  v_arr_ts       TIMESTAMP;

  --------------------------------------------------------------------
  -- Local types and helpers
  --------------------------------------------------------------------
  TYPE t_numset IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;

  -- Monday=1 .. Sunday=7
  FUNCTION weekday_mon1(p_date DATE) RETURN PLS_INTEGER IS
  BEGIN
    RETURN MOD(TRUNC(p_date) - DATE '1900-01-01', 7) + 1;
  END;

  -- Parse '1,3,5' into a set-like table
  FUNCTION parse_weekdays(p VARCHAR2) RETURN t_numset IS
    v_set t_numset;
    v_s   VARCHAR2(2000) := NVL(TRIM(p), '');
    v_tok VARCHAR2(10);
    v_pos PLS_INTEGER := 1;
  BEGIN
    IF v_s IS NULL OR v_s = '' THEN
      RETURN v_set;
    END IF;
    LOOP
      v_tok := REGEXP_SUBSTR(v_s, '([^,]+)', 1, v_pos);
      EXIT WHEN v_tok IS NULL;
      v_set(TO_NUMBER(TRIM(v_tok))) := 1;
      v_pos := v_pos + 1;
    END LOOP;
    RETURN v_set;
  END;

  -- Combine a date with 'HH24:MI'
  FUNCTION at_time(p_date DATE, p_hhmi VARCHAR2) RETURN TIMESTAMP IS
  BEGIN
    RETURN TO_TIMESTAMP(TO_CHAR(p_date, 'YYYY-MM-DD')||' '||p_hhmi, 'YYYY-MM-DD HH24:MI');
  END;

  -- Compute arrival
  FUNCTION calc_arrival(p_dep_ts TIMESTAMP,
                        p_est_min NUMBER,
                        p_arr_hhmi VARCHAR2) RETURN TIMESTAMP IS
    v_dep_date DATE := CAST(p_dep_ts AS DATE);
    v_dep_hm   VARCHAR2(5) := TO_CHAR(p_dep_ts, 'HH24:MI');
    v_arr_ts   TIMESTAMP;
  BEGIN
    IF p_est_min IS NOT NULL THEN
      RETURN p_dep_ts + NUMTODSINTERVAL(p_est_min, 'MINUTE');
    ELSIF p_arr_hhmi IS NOT NULL THEN
      v_arr_ts := at_time(v_dep_date, p_arr_hhmi);
      IF TO_CHAR(v_arr_ts, 'HH24:MI') < v_dep_hm THEN
        v_arr_ts := v_arr_ts + NUMTODSINTERVAL(1, 'DAY'); -- overnight
      END IF;
      RETURN v_arr_ts;
    ELSE
      RETURN p_dep_ts + NUMTODSINTERVAL(120, 'MINUTE'); -- default 2h
    END IF;
  END;

  --------------------------------------------------------------------
  -- New: helpers for 12-char ID
  --------------------------------------------------------------------
  -- base36 编码：固定宽度，不足左侧补 0，超长左截断
  FUNCTION to_base36(n IN NUMBER, width IN PLS_INTEGER) RETURN VARCHAR2 IS
    chars CONSTANT VARCHAR2(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    v     NUMBER := FLOOR(ABS(NVL(n,0)));
    out   VARCHAR2(64) := '';
  BEGIN
    IF v = 0 THEN out := '0'; END IF;
    WHILE v > 0 LOOP
      out := SUBSTR(chars, MOD(v, 36) + 1, 1) || out;
      v := FLOOR(v / 36);
    END LOOP;
    IF LENGTH(out) < width THEN
      out := LPAD(out, width, '0');
    ELSIF LENGTH(out) > width THEN
      out := SUBSTR(out, LENGTH(out) - width + 1);
    END IF;
    RETURN out;
  END;

  -- 生成 12 字符：'S' + 8位base36时间戳 + 3位base36哈希
  FUNCTION make_bs_id(p_dep_ts TIMESTAMP, p_rda_id VARCHAR2) RETURN VARCHAR2 IS
    j         NUMBER := TO_NUMBER(TO_CHAR(CAST(p_dep_ts AS DATE), 'J'));
    s         NUMBER := TO_NUMBER(TO_CHAR(CAST(p_dep_ts AS DATE), 'SSSSS'));
    epoch_sec NUMBER := j*86400 + s;
    ts36      VARCHAR2(8) := to_base36(epoch_sec, 8);
    h         NUMBER := DBMS_UTILITY.get_hash_value(UPPER(NVL(p_rda_id,'X')), 0, 36*36*36 - 1);
    h36       VARCHAR2(3) := to_base36(h, 3);
  BEGIN
    RETURN 'S' || ts36 || h36;  -- 长度恒为 12
  END;

  -- profit
  FUNCTION calc_profit(p_distance NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN ROUND(NVL(p_distance, 100) * 0.6 + DBMS_RANDOM.VALUE(50, 150), 2);
  END;

  -- upsert-ish
  PROCEDURE insert_if_absent(p_rda_id VARCHAR2, p_dep_ts TIMESTAMP, p_arr_ts TIMESTAMP, p_profit NUMBER) IS
    v_exists NUMBER;
    v_id     VARCHAR2(12);
  BEGIN
    SELECT COUNT(*)
      INTO v_exists
      FROM busSchedule
     WHERE routeDriverAssignmentId = p_rda_id
       AND plannedDepartureTime    = p_dep_ts;

    IF v_exists = 0 THEN
      v_id := make_bs_id(p_dep_ts, p_rda_id);
      INSERT INTO busSchedule(
        busScheduleId, routeDriverAssignmentId,
        plannedDepartureTime, plannedArrivalTime,
        status, expectedProfit, remarks
      ) VALUES (
        v_id, p_rda_id,
        p_dep_ts, p_arr_ts,
        'Planned', p_profit, 'auto-generated'
      );
    END IF;
  END;

BEGIN
  --------------------------------------------------------------------
  -- Load the RDA row
  --------------------------------------------------------------------
  SELECT routeId, assignmentId, frequency, weekdays, effectiveFrom, effectiveTo, status
    INTO v_route_id, v_assignment_id, v_freq, v_weekdays, v_eff_from, v_eff_to, v_status
  FROM routeDriverAssignmentList
  WHERE routeDriverAssignmentId = p_rda_id;

  IF LOWER(v_status) <> 'active' THEN
    RETURN;
  END IF;

  --------------------------------------------------------------------
  -- Load Route data
  --------------------------------------------------------------------
  SELECT plannedDepartureTime, plannedArrivalTime, estimatedDuration, distanceKm
    INTO v_dep_hhmm, v_arr_hhmm, v_est_min, v_distance_km
  FROM route
  WHERE routeId = v_route_id;

  v_start_date := TRUNC(v_eff_from);
  v_end_date   := CASE
                    WHEN v_eff_to IS NOT NULL THEN TRUNC(v_eff_to)
                    ELSE TRUNC(v_eff_from) + p_max_days
                  END;

  --------------------------------------------------------------------
  -- Frequency branches
  --------------------------------------------------------------------
  IF LOWER(v_freq) = 'daily' THEN

    FOR d IN 0 .. (v_end_date - v_start_date) LOOP
      v_dep_ts := at_time(v_start_date + d, v_dep_hhmm);
      v_arr_ts := calc_arrival(v_dep_ts, v_est_min, v_arr_hhmm);
      insert_if_absent(p_rda_id, v_dep_ts, v_arr_ts, calc_profit(v_distance_km));
    END LOOP;

  ELSIF LOWER(v_freq) = 'weekly' THEN
    DECLARE
      v_set t_numset := parse_weekdays(v_weekdays); -- 1..7 = Mon..Sun
      v_d   DATE := v_start_date;
      v_w   PLS_INTEGER;
    BEGIN
      WHILE v_d <= v_end_date LOOP
        v_w := weekday_mon1(v_d);
        IF v_set.EXISTS(v_w) THEN
          v_dep_ts := at_time(v_d, v_dep_hhmm);
          v_arr_ts := calc_arrival(v_dep_ts, v_est_min, v_arr_hhmm);
          insert_if_absent(p_rda_id, v_dep_ts, v_arr_ts, calc_profit(v_distance_km));
        END IF;
        v_d := v_d + 1;
      END LOOP;
    END;

  ELSIF LOWER(v_freq) = 'monthly' THEN
    DECLARE
      v_day  PLS_INTEGER := TO_NUMBER(TO_CHAR(v_start_date, 'DD'));
      v_cur  DATE := v_start_date;
      v_m    DATE;
      v_try  DATE;
      v_eom  DATE;
    BEGIN
      WHILE v_cur <= v_end_date LOOP
        v_m   := TRUNC(v_cur, 'MM');
        v_eom := TRUNC(ADD_MONTHS(v_m, 1) - 1);
        v_try := v_m + (v_day - 1);
        IF v_try > v_eom THEN
          v_try := v_eom;
        END IF;

        IF v_try BETWEEN v_start_date AND v_end_date THEN
          v_dep_ts := at_time(v_try, v_dep_hhmm);
          v_arr_ts := calc_arrival(v_dep_ts, v_est_min, v_arr_hhmm);
          insert_if_absent(p_rda_id, v_dep_ts, v_arr_ts, calc_profit(v_distance_km));
        END IF;

        v_cur := ADD_MONTHS(v_cur, 1);
      END LOOP;
    END;

  ELSE
    NULL; -- unknown frequency
  END IF;
END;
/
