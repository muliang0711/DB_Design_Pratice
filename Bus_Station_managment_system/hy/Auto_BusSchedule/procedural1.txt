CREATE OR REPLACE PROCEDURE GEN_BUS_SCHEDULES (
  p_assignment_id   IN routeDriverAssignmentList.routeDriverAssignmentId%TYPE,
  p_max_days        IN NUMBER DEFAULT 1
) IS

  route_id                route.routeId%TYPE;
  assignment_reference_id routeDriverAssignmentList.assignmentId%TYPE;
  frequency_type          routeDriverAssignmentList.frequency%TYPE;
  weekdays_string         routeDriverAssignmentList.weekdays%TYPE;
  effective_from_date     DATE;
  effective_to_date       DATE;
  assignment_status       routeDriverAssignmentList.status%TYPE;

  planned_departure_hhmm  route.plannedDepartureTime%TYPE;
  planned_arrival_hhmm    route.plannedArrivalTime%TYPE;
  estimated_duration_min  route.estimatedDuration%TYPE;
  route_distance_km       route.distanceKm%TYPE;

  schedule_start_date     DATE;
  schedule_end_date       DATE;
  departure_timestamp     TIMESTAMP;
  arrival_timestamp       TIMESTAMP;

  -- custom exceptions
  ex_assignment_not_found   EXCEPTION;
  ex_inactive_assignment    EXCEPTION;
  ex_route_not_found        EXCEPTION;
  ex_invalid_frequency      EXCEPTION;

  PRAGMA EXCEPTION_INIT(ex_assignment_not_found, -20001);
  PRAGMA EXCEPTION_INIT(ex_inactive_assignment, -20002);
  PRAGMA EXCEPTION_INIT(ex_route_not_found, -20003);
  PRAGMA EXCEPTION_INIT(ex_invalid_frequency, -20004);

  TYPE weekday_set IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;

  -------------------------------------------------------------------
  -- Utility functions (unchanged, except shortened for clarity)
  -------------------------------------------------------------------
  FUNCTION get_weekday_mon1(p_date DATE) RETURN PLS_INTEGER IS
  BEGIN
    RETURN MOD(TRUNC(p_date) - DATE '1900-01-01', 7) + 1;
  END;

  FUNCTION parse_weekdays(p VARCHAR2) RETURN weekday_set IS
    weekday_numbers weekday_set;
    weekdays_input  VARCHAR2(2000) := NVL(TRIM(p), '');
    weekday_token   VARCHAR2(10);
    position_index  PLS_INTEGER := 1;
  BEGIN
    LOOP
      weekday_token := REGEXP_SUBSTR(weekdays_input, '([^,]+)', 1, position_index);
      EXIT WHEN weekday_token IS NULL;
      weekday_numbers(TO_NUMBER(TRIM(weekday_token))) := 1;
      position_index := position_index + 1;
    END LOOP;
    RETURN weekday_numbers;
  END;

  FUNCTION to_timestamp_with_time(p_date DATE, p_hhmi VARCHAR2) RETURN TIMESTAMP IS
  BEGIN
    RETURN TO_TIMESTAMP(TO_CHAR(p_date, 'YYYY-MM-DD')||' '||p_hhmi, 'YYYY-MM-DD HH24:MI');
  END;

  FUNCTION calculate_arrival_time(
                        departure_ts TIMESTAMP,
                        estimated_minutes NUMBER,
                        arrival_hhmi VARCHAR2) RETURN TIMESTAMP IS
    dep_date   DATE := CAST(departure_ts AS DATE);
    dep_hhmi   VARCHAR2(5) := TO_CHAR(departure_ts, 'HH24:MI');
    calc_arrival_ts TIMESTAMP;
  BEGIN
    IF estimated_minutes IS NOT NULL THEN
      RETURN departure_ts + NUMTODSINTERVAL(estimated_minutes, 'MINUTE');
    ELSIF arrival_hhmi IS NOT NULL THEN
      calc_arrival_ts := to_timestamp_with_time(dep_date, arrival_hhmi);
      IF TO_CHAR(calc_arrival_ts, 'HH24:MI') < dep_hhmi THEN
        calc_arrival_ts := calc_arrival_ts + NUMTODSINTERVAL(1, 'DAY');
      END IF;
      RETURN calc_arrival_ts;
    ELSE
      RETURN departure_ts + NUMTODSINTERVAL(120, 'MINUTE'); -- fallback 2h
    END IF;
  END;

  FUNCTION generate_bus_schedule_id RETURN VARCHAR2 IS
    generated_id VARCHAR2(20);
  BEGIN
    SELECT 'S' || LPAD(bus_schedule_seq.NEXTVAL, 6, '0')
      INTO generated_id
      FROM dual;
    RETURN generated_id;
  END;

  FUNCTION calculate_expected_profit(distance_km NUMBER) RETURN NUMBER IS
  BEGIN
    RETURN ROUND(NVL(distance_km, 100) * 0.6 + DBMS_RANDOM.VALUE(50, 150), 2);
  END;

  PROCEDURE insert_schedule_if_not_exists(
    assignment_id_input VARCHAR2,
    departure_ts        TIMESTAMP,
    arrival_ts          TIMESTAMP,
    profit_value        NUMBER
  ) IS
    existing_count NUMBER;
    new_schedule_id VARCHAR2(12);
  BEGIN
    SELECT COUNT(*)
      INTO existing_count
      FROM busSchedule
     WHERE routeDriverAssignmentId = assignment_id_input
       AND plannedDepartureTime    = departure_ts;

    IF existing_count = 0 THEN
      new_schedule_id := generate_bus_schedule_id;
      INSERT INTO busSchedule(
        busScheduleId, routeDriverAssignmentId,
        plannedDepartureTime, plannedArrivalTime,
        status, expectedProfit, remarks
      ) VALUES (
        new_schedule_id, assignment_id_input,
        departure_ts, arrival_ts,
        'Planned', profit_value, 'auto-generated'
      );
    END IF;
  END;

BEGIN
  -- 1. Load assignment
  BEGIN
    SELECT routeId, assignmentId, frequency, weekdays, effectiveFrom, effectiveTo, status
      INTO route_id, assignment_reference_id, frequency_type, weekdays_string,
           effective_from_date, effective_to_date, assignment_status
    FROM routeDriverAssignmentList
    WHERE routeDriverAssignmentId = p_assignment_id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20001, 'Assignment ID '||p_assignment_id||' not found.');
  END;

  -- 2. Check assignment active
  IF LOWER(assignment_status) <> 'active' THEN
    RAISE_APPLICATION_ERROR(-20002, 'Assignment '||p_assignment_id||' is not active.');
  END IF;

  -- 3. Load route
  BEGIN
    SELECT plannedDepartureTime, plannedArrivalTime, estimatedDuration, distanceKm
      INTO planned_departure_hhmm, planned_arrival_hhmm, estimated_duration_min, route_distance_km
    FROM route
    WHERE routeId = route_id;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20003, 'Route '||route_id||' not found for assignment '||p_assignment_id);
  END;

  -- 4. Calculate date range
  schedule_start_date := TRUNC(effective_from_date);
  schedule_end_date   := CASE
                    WHEN effective_to_date IS NOT NULL THEN TRUNC(effective_to_date)
                    ELSE TRUNC(effective_from_date) + p_max_days
                  END;

  -- 5. Frequency logic
  IF LOWER(frequency_type) = 'daily' THEN
    FOR day_offset IN 0 .. (schedule_end_date - schedule_start_date) LOOP
      departure_timestamp := to_timestamp_with_time(schedule_start_date + day_offset, planned_departure_hhmm);
      arrival_timestamp   := calculate_arrival_time(departure_timestamp, estimated_duration_min, planned_arrival_hhmm);
      insert_schedule_if_not_exists(p_assignment_id, departure_timestamp, arrival_timestamp, calculate_expected_profit(route_distance_km));
    END LOOP;

  ELSIF LOWER(frequency_type) = 'weekly' THEN
    DECLARE
      active_weekdays weekday_set := parse_weekdays(weekdays_string);
      current_date DATE := schedule_start_date;
      weekday_number PLS_INTEGER;
    BEGIN
      WHILE current_date <= schedule_end_date LOOP
        weekday_number := get_weekday_mon1(current_date);
        IF active_weekdays.EXISTS(weekday_number) THEN
          departure_timestamp := to_timestamp_with_time(current_date, planned_departure_hhmm);
          arrival_timestamp   := calculate_arrival_time(departure_timestamp, estimated_duration_min, planned_arrival_hhmm);
          insert_schedule_if_not_exists(p_assignment_id, departure_timestamp, arrival_timestamp, calculate_expected_profit(route_distance_km));
        END IF;
        current_date := current_date + 1;
      END LOOP;
    END;

  ELSIF LOWER(frequency_type) = 'monthly' THEN
    DECLARE
      assignment_day_number PLS_INTEGER := TO_NUMBER(TO_CHAR(schedule_start_date, 'DD'));
      current_month_start   DATE := schedule_start_date;
      month_start           DATE;
      try_date              DATE;
      end_of_month          DATE;
    BEGIN
      WHILE current_month_start <= schedule_end_date LOOP
        month_start   := TRUNC(current_month_start, 'MM');
        end_of_month  := TRUNC(ADD_MONTHS(month_start, 1) - 1);
        try_date      := month_start + (assignment_day_number - 1);
        IF try_date > end_of_month THEN
          try_date := end_of_month;
        END IF;

        IF try_date BETWEEN schedule_start_date AND schedule_end_date THEN
          departure_timestamp := to_timestamp_with_time(try_date, planned_departure_hhmm);
          arrival_timestamp   := calculate_arrival_time(departure_timestamp, estimated_duration_min, planned_arrival_hhmm);
          insert_schedule_if_not_exists(p_assignment_id, departure_timestamp, arrival_timestamp, calculate_expected_profit(route_distance_km));
        END IF;

        current_month_start := ADD_MONTHS(current_month_start, 1);
      END LOOP;
    END;

  ELSE
    RAISE_APPLICATION_ERROR(-20004, 'Invalid frequency "'||frequency_type||'" for assignment '||p_assignment_id);
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    -- fallback: catch any unhandled error
    RAISE_APPLICATION_ERROR(-20999, 'Unexpected error in GEN_BUS_SCHEDULES: '||SQLERRM);
END;
/


SHOW ERRORS PROCEDURE GEN_BUS_SCHEDULES;


EXEC GEN_BUS_SCHEDULES('RD407');

SELECT * 
FROM busSchedule 
WHERE routeDriverAssignmentId = 'RD407'
ORDER BY plannedDepartureTime;

INSERT INTO routeDriverAssignmentList (routeDriverAssignmentId, routeId, assignmentId, frequency, weekdays, effectiveFrom, effectiveTo, status, expectedProfit, remarks) VALUES 
('RD407', 'R091', 'A000187', 'daily', '1,7', TO_DATE('2025-02-27', 'YYYY-MM-DD'), TO_DATE('2026-02-16', 'YYYY-MM-DD'), 'active', 4318.65, 'Auto-generated assignment 399');

SELECT * 
FROM busSchedule 
WHERE routeDriverAssignmentId = 'RD407'
ORDER BY plannedDepartureTime;
