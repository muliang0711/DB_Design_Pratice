輸入：p_scheduleID（你要產生票的 BusScheduleID）

1. 查出該 BusSchedule 對應的 Driver Assignment ID（司機任務）和建立時間。
2. 根據 Assignment ID 查出所使用的 Bus（巴士）ID。
3. 根據 Bus ID 查出巴士的容量（即座位數）。
4. 根據容量，用一個迴圈從 1 到 capacity 產生對應數量的車票：
   - 每張票對應一個 seatNumber。
   - 如果班次的建立時間在最近 7 天內，票的狀態為 `booking`，否則為 `regular`。

CREATE OR REPLACE PROCEDURE GenerateTicketsForBusSchedule(p_scheduleID IN NUMBER) IS
  v_assignmentID NUMBER;
  v_busID NUMBER;
  v_capacity NUMBER;
  v_createdAt TIMESTAMP;
BEGIN
  -- Step 1: Get assignment ID and created date
  SELECT rdal.assignmentID, bs.createdAt
  INTO v_assignmentID, v_createdAt
  FROM BusSchedule bs
  JOIN RouteDriverAssignmentList rdal
    ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE bs.BusScheduleID = p_scheduleID;

  -- Step 2: Get bus ID
  SELECT busID INTO v_busID
  FROM DriverListAssignment
  WHERE assignmentID = v_assignmentID;

  -- Step 3: Get bus capacity
  SELECT capacity INTO v_capacity
  FROM Bus
  WHERE busID = v_busID;

  -- Step 4: Insert tickets based on capacity
  FOR i IN 1..v_capacity LOOP
    INSERT INTO BusScheduleTicket (
      ticketID, BusScheduleID, seatNumber, status, createdAt
    ) VALUES (
      BusScheduleTicket_seq.NEXTVAL,
      p_scheduleID,
      i,
      CASE
        WHEN v_createdAt >= SYSDATE - 7 THEN 'booking'
        ELSE 'regular'
      END,
      SYSDATE
    );
  END LOOP;
END;
/
CREATE OR REPLACE TRIGGER trg_create_tickets_on_planned
AFTER UPDATE OF status ON BusSchedule
FOR EACH ROW
WHEN (OLD.status = 'Pending' AND NEW.status = 'Planned')
BEGIN
  GenerateTicketsForBusSchedule(:NEW.BusScheduleID);
END;
/

Trigger : detect when a BusSchedule is set to Planned and auto-generate tickets.

CREATE OR REPLACE TRIGGER trg_create_tickets_on_planned
AFTER UPDATE OF status ON BusSchedule
FOR EACH ROW
WHEN (OLD.status = 'Pending' AND NEW.status = 'Planned')
BEGIN
  -- Call the stored procedure to generate tickets
  GenerateTicketsForBusSchedule(:NEW.BusScheduleID);
END;
/


輸入：daysAhead（往後幾天，自動產生的班次數）

1. 開一個游標讀取所有啟用狀態（status = active）的 RouteDriverAssignmentList。
2. 對於今天起接下來的每一天（0 到 daysAhead）：
   - 檢查當天的星期幾是否包含在該重複排班的 weekdays 中。
   - 檢查當天是否在 effectiveFrom ~ effectiveTo 的有效期內。
   - 如果符合條件：
     - 根據該天的日期 + 原設定的出發與抵達時間，建立完整的時間戳。
     - 檢查是否已有重複的 BusSchedule（用 routeDriverAssignmentID + plannedDepartureTime 當唯一鍵），避免重複插入。
     - 若沒有，插入一筆新的 BusSchedule，狀態設為 `Pending`，說明為 `Auto-generated`。

CREATE OR REPLACE PROCEDURE GenerateBusSchedulesFromRecurring(daysAhead IN NUMBER) IS
  CURSOR recurring_cursor IS
    SELECT rdal.*, r.plannedDepartureTime, r.plannedArrivalTime
    FROM RouteDriverAssignmentList rdal
    JOIN Route r ON r.routeID = rdal.routeID
    WHERE rdal.status = 'active';

  v_date DATE;
  v_weekday VARCHAR2(1);
  v_dep TIMESTAMP;
  v_arr TIMESTAMP;
BEGIN
  FOR i IN 0 .. daysAhead LOOP
    v_date := TRUNC(SYSDATE) + i; -- today + i
    v_weekday := TO_CHAR(v_date, 'D'); -- weekday as string (1-7, depends on NLS)

    FOR rec IN recurring_cursor LOOP
      -- Check if this date is in assignment range and weekday matches
      IF v_date BETWEEN rec.effectiveFrom AND NVL(rec.effectiveTo, v_date)
         AND INSTR(',' || rec.weekdays || ',', ',' || v_weekday || ',') > 0 THEN

        -- Construct full timestamp for departure and arrival
        v_dep := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedDepartureTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');
        v_arr := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedArrivalTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');

        -- Avoid duplicate entries by routeDriverAssignmentID + plannedDepartureTime
        IF NOT EXISTS (
          SELECT 1 FROM BusSchedule
          WHERE routeDriverAssignmentID = rec.routeDriverAssignmentID
            AND plannedDepartureTime = v_dep
        ) THEN
          INSERT INTO BusSchedule (
            BusScheduleID, routeDriverAssignmentID, plannedDepartureTime, plannedArrivalTime,
            status, remarks, createdAt, updatedAt
          ) VALUES (
            BusSchedule_seq.NEXTVAL,
            rec.routeDriverAssignmentID,
            v_dep,
            v_arr,
            'Pending', -- Initial status
            'Auto-generated by recurring assignment',
            SYSDATE,
            SYSDATE
          );
        END IF;

      END IF;
    END LOOP;
  END LOOP;
END;
/

Trigger : auto generate BusSchedules from recurring assignments

BEGIN
  DBMS_SCHEDULER.create_job (
    job_name        => 'JOB_GENERATE_BUSES',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'GenerateBusSchedulesFromRecurring',
    number_of_arguments => 1,
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=00;BYMINUTE=00',
    enabled         => FALSE
  );

  -- Set daysAhead = 7
  DBMS_SCHEDULER.set_job_argument_value('JOB_GENERATE_BUSES', 1, 7);

  DBMS_SCHEDULER.enable('JOB_GENERATE_BUSES');
END;
/