輸入：p_scheduleID（你要產生票的 BusScheduleID）

1. 查出該 BusSchedule 對應的 RouteDriverAssignmentList.assignmentID（司機任務）、
   班次建立時間（createdAt）與預定出發時間（plannedDepartureTime）。

2. 根據 assignmentID 查出對應的 DriverListAssignment → 取得 busID（該班次所使用的巴士 ID）。

3. 根據 busID 查出 Bus 資料 → 取得巴士的容量（即座位數）。

4. 開啟一個 nested cursor（內層游標），從 1 到 capacity，對每個座位進行以下操作：
   - 產生座位編號（seatNo）：格式為 `BUS<busID>-A<座位號>`，例如 `BUS12-A1`
   - 判斷出發時間（plannedDepartureTime）是否在 7 天後：
     - 如果在 7 天後，則票的狀態為 `'booking'`
     - 否則為 `'regular'`
   - 將以上資訊插入 Ticket 表中（customerID 為 NULL，代表尚未購票）

5. 每一張票的產生都包在 `EXCEPTION` 區塊中，以防止某些座位插入失敗導致整體程序終止。

CREATE OR REPLACE PROCEDURE GenerateTicketsForBusSchedule(p_scheduleID IN NUMBER) IS
  -- Variables
  v_assignmentID   DriverListAssignment.assignmentID%TYPE;
  v_busID          Bus.busID%TYPE;
  v_capacity       Bus.capacity%TYPE;
  v_createdAt      BusSchedule.createdAt%TYPE;
  v_departureTime  BusSchedule.plannedDepartureTime%TYPE;

  -- Cursor to simulate step-by-step extraction
  CURSOR c_schedule IS
    SELECT rdal.assignmentID, bs.createdAt, bs.plannedDepartureTime
    FROM BusSchedule bs
    JOIN RouteDriverAssignmentList rdal
      ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    WHERE bs.BusScheduleID = p_scheduleID;

  -- Cursor to simulate ticket generation for each seat
  CURSOR c_seatCapacity(p_capacity NUMBER) IS
    SELECT LEVEL AS seat_no FROM dual CONNECT BY LEVEL <= p_capacity;

BEGIN
  -- Outer cursor (simulate scan)
  FOR sched IN c_schedule LOOP
    BEGIN
      -- Step 1: Save values
      v_assignmentID := sched.assignmentID;
      v_createdAt := sched.createdAt;
      v_departureTime := sched.plannedDepartureTime;

      -- Step 2: Lookup busID from DriverListAssignment
      BEGIN
        SELECT busID INTO v_busID
        FROM DriverListAssignment
        WHERE assignmentID = v_assignmentID;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('No assignment found for assignmentID: ' || v_assignmentID);
          RETURN;
        WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Error getting busID: ' || SQLERRM);
          RETURN;
      END;

      -- Step 3: Get bus capacity
      BEGIN
        SELECT capacity INTO v_capacity
        FROM Bus
        WHERE busID = v_busID;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('No bus found for busID: ' || v_busID);
          RETURN;
        WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Error getting bus capacity: ' || SQLERRM);
          RETURN;
      END;

      -- Step 4: Loop through each seat using nested cursor
      FOR seat IN c_seatCapacity(v_capacity) LOOP
        BEGIN
          INSERT INTO Ticket (
            ticketID, BusScheduleID, customerID, seatNo, type, createdAt
          ) VALUES (
            Ticket_seq.NEXTVAL,
            p_scheduleID,
            NULL, -- No customer assigned yet
            'BUS' || v_busID || '-A' || TO_CHAR(seat.seat_no),
            CASE
              WHEN v_departureTime > SYSDATE + 7 THEN 'booking'
              ELSE 'regular'
            END,
            SYSDATE
          );
        EXCEPTION
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Failed to insert ticket for seat ' || seat.seat_no || ': ' || SQLERRM);
        END;
      END LOOP;

      DBMS_OUTPUT.PUT_LINE('Tickets generated for BusScheduleID: ' || p_scheduleID);
    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('General error during schedule processing: ' || SQLERRM);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error in outer block: ' || SQLERRM);
END;
/


/
Trigger : detect when a BusSchedule is set to Planned and auto-generate tickets.

CREATE OR REPLACE TRIGGER trg_create_tickets_on_planned
AFTER UPDATE OF status ON BusSchedule
FOR EACH ROW
WHEN (OLD.status = 'Pending' AND NEW.status = 'Planned')
BEGIN
  GenerateTicketsForBusSchedule(:NEW.BusScheduleID);
  -- if 
  -- commit 
  -- else 
  -- rollback 
  -- show error message
END;
/


輸入：daysAhead（往後幾天，自動產生的班次數）

1. 開一個游標讀取所有啟用狀態（status = 'active'）的 RouteDriverAssignmentList，
   並且 JOIN Route 以取得原始的出發與抵達時間，
   JOIN DriverListAssignment 以取得對應的 driverID 和其 assign 時間範圍（assignedFrom / assignedTo）。

2. 對於今天起接下來的每一天（0 到 daysAhead）：
   - 取出今天的星期幾（1=星期日，依據 NLS_TERRITORY 而定）
   - 檢查當天的星期幾是否包含在該排班的 weekdays 設定中。
   - 檢查當天是否在該 RouteDriverAssignment 的有效期間（effectiveFrom ~ effectiveTo）內。
   - 檢查當天是否在該 driver 的指派期間（assignedFrom ~ assignedTo）內。
     → 若不在指派期間，跳過該筆資料（該天未被指派）。

3. 如果以上條件都符合：
   - 根據該天的日期 + 原始設定的出發與抵達時間，組成完整的 timestamp。
     例如：2025-07-20 + 08:00 → 2025-07-20 08:00:00
   - 檢查是否已有重複的 BusSchedule（以 routeDriverAssignmentID + plannedDepartureTime 為唯一鍵）。
     → 若已存在，跳過不處理。
   - 若沒有重複：
     - 插入一筆新的 BusSchedule。
     - 設定狀態為 `Pending`。
     - 說明（remarks）填入 `Auto-generated by recurring assignment`。

CREATE OR REPLACE PROCEDURE GenerateBusSchedulesFromRecurring(daysAhead IN NUMBER) IS
  -- Outer cursor: active recurring assignments + route time + driver ID
  CURSOR c_recurring IS
    SELECT 
      rdal.*, 
      r.plannedDepartureTime, 
      r.plannedArrivalTime, 
      dla.driverID
    FROM RouteDriverAssignmentList rdal
    JOIN Route r ON r.routeID = rdal.routeID
    JOIN DriverListAssignment dla ON rdal.assignmentID = dla.assignmentID
    WHERE rdal.status = 'active';

  -- Nested cursor: check if driver is assigned to bus on that date
  CURSOR c_driverCheck(p_driverID NUMBER, p_date DATE) IS
    SELECT assignmentID
    FROM DriverListAssignment
    WHERE driverID = p_driverID
      AND TRUNC(p_date) BETWEEN TRUNC(assignedFrom) AND TRUNC(NVL(assignedTo, p_date));

  -- Variables
  v_date       DATE;
  v_weekday    VARCHAR2(1);
  v_dep        TIMESTAMP;
  v_arr        TIMESTAMP;
  rec          c_recurring%ROWTYPE;
  v_exists     NUMBER;
  v_dummy      DriverListAssignment.assignmentID%TYPE;

BEGIN
  FOR i IN 0 .. daysAhead LOOP
    BEGIN
      v_date := TRUNC(SYSDATE) + i;
      v_weekday := TO_CHAR(v_date, 'D'); -- 1 = Sunday (depends on NLS_TERRITORY)

      OPEN c_recurring;
      LOOP
        FETCH c_recurring INTO rec;
        EXIT WHEN c_recurring%NOTFOUND;

        BEGIN
          -- Check weekday match and effective date range
          IF v_date BETWEEN rec.effectiveFrom AND NVL(rec.effectiveTo, v_date)
             AND INSTR(',' || rec.weekdays || ',', ',' || v_weekday || ',') > 0 THEN

            -- Construct full timestamps for departure and arrival
            v_dep := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedDepartureTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');
            v_arr := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedArrivalTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');

            -- Check if the driver IS assigned to the bus on this day
            OPEN c_driverCheck(rec.driverID, v_date);
            FETCH c_driverCheck INTO v_dummy;
            IF NOT c_driverCheck%FOUND THEN
              DBMS_OUTPUT.PUT_LINE('Driver ' || rec.driverID || ' is not assigned to any bus on ' || TO_CHAR(v_date));
              CLOSE c_driverCheck;
              CONTINUE; -- Skip this assignment
            END IF;
            CLOSE c_driverCheck;

            -- Check for existing schedule (avoid duplicates)
            SELECT COUNT(*) INTO v_exists
            FROM BusSchedule
            WHERE routeDriverAssignmentID = rec.routeDriverAssignmentID
              AND plannedDepartureTime = v_dep;

            -- Insert new schedule if not exists
            IF v_exists = 0 THEN
              INSERT INTO BusSchedule (
                BusScheduleID, routeDriverAssignmentID, plannedDepartureTime, plannedArrivalTime,
                status, remarks, createdAt, updatedAt
              ) VALUES (
                BusSchedule_seq.NEXTVAL,
                rec.routeDriverAssignmentID,
                v_dep,
                v_arr,
                'Pending',
                'Auto-generated by recurring assignment',
                SYSDATE,
                SYSDATE
              );
              DBMS_OUTPUT.PUT_LINE('Inserted BusSchedule on ' || TO_CHAR(v_dep, 'YYYY-MM-DD HH24:MI'));
            ELSE
              DBMS_OUTPUT.PUT_LINE('Duplicate found for ' || TO_CHAR(v_dep, 'YYYY-MM-DD HH24:MI'));
            END IF;

          END IF;

        EXCEPTION
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error in assignment ID ' || rec.routeDriverAssignmentID || ': ' || SQLERRM);
        END;

      END LOOP;
      CLOSE c_recurring;

    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error processing day ' || TO_CHAR(v_date, 'YYYY-MM-DD') || ': ' || SQLERRM);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error in procedure: ' || SQLERRM);
END;
/




Trigger : auto generate BusSchedules from recurring assignments

BEGIN
  DBMS_SCHEDULER.create_job (
    job_name        => 'JOB_GENERATE_BUSES',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'GenerateBusSchedulesFromRecurring',
    number_of_arguments => 1,
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=00;BYMINUTE=00',
    enabled         => FALSE
  );

  -- Set daysAhead = 7
  DBMS_SCHEDULER.set_job_argument_value('JOB_GENERATE_BUSES', 1, 7);
  -- if 
  -- commit
  -- else
  -- rollback
  -- enable the job
  DBMS_SCHEDULER.enable('JOB_GENERATE_BUSES');
END;
/

we need a script to auto-update all the BusSchedule status to planned from pending when it being auto-generated.

CREATE OR REPLACE PROCEDURE UpdatePendingSchedulesToPlanned IS
  CURSOR pending_cursor IS
    SELECT BusScheduleID
    FROM BusSchedule
    WHERE status = 'Pending';
  v_scheduleID NUMBER;
BEGIN
  FOR rec IN pending_cursor LOOP
    v_scheduleID := rec.BusScheduleID;

    -- Update status to Planned
    UPDATE BusSchedule
    SET status = 'Planned',
        updatedAt = SYSDATE
    WHERE BusScheduleID = v_scheduleID;

    DBMS_OUTPUT.PUT_LINE('Updated BusScheduleID ' || v_scheduleID || ' to Planned.');
  END LOOP;
END;

two report : 
1. Route Profitability and Efficiency Report -- to decide drop or keep which route

輸入：無
輸出：列印每條 Route 下的 BusSchedule 與利潤表現報告

1. 開啟外層游標：取得所有 Route 資料
   - routeID, routeName

2. 對於每個 routeID 開啟內層游標：抓取該路線下的 BusSchedules
   - 利用 RouteDriverAssignmentList 找出 routeDriverAssignmentID
   - 找到 BusSchedule 並 JOIN Ticket 計算實際營收與利潤 When 
   - Ticket.status = 'been_bought'
   - Ticket.customerID IS NOT NULL

3. 對於每筆 BusSchedule：
   - 計算 SUM(price)、profit = revenue - 150
   - 與 expectedProfit 比較 → 決定結果（Profitable / Underperformed）

4. 模擬分組顯示：若為新的 route 才印出 route 資訊

5. 資料格式化輸出（使用 RPAD 與 TO_CHAR 對齊欄位）：
   欄位包含：
   - routeID
   - routeName
   - routeExpectedProfit
   - scheduleID
   - scheduleExpectedProfit
   - cost（固定 150）
   - actualRevenue（總票價）
   - actualProfit（實際利潤）
   - scheduleResult（Profitable 或 Underperformed）


CREATE OR REPLACE PROCEDURE ReportRouteScheduleProfit_Nested IS
  -- Variable to track previous routeID
  v_lastRouteID Route.routeID%TYPE := NULL;

  -- Outer cursor: All routes
  CURSOR c_routes IS
    SELECT routeID, routeName FROM Route ORDER BY routeID;

  -- Inner cursor: BusSchedules under a specific route (only count sold tickets)
  CURSOR c_schedules(p_routeID Route.routeID%TYPE) IS
    SELECT 
      bs.BusScheduleID,
      rdal.expectedProfit AS routeExpectedProfit,
      bs.expectedProfit AS scheduleExpectedProfit,
      COALESCE(SUM(t.price), 0) AS actualRevenue
    FROM RouteDriverAssignmentList rdal
    JOIN BusSchedule bs ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    LEFT JOIN Ticket t 
      ON t.BusScheduleID = bs.BusScheduleID 
     AND t.status = 'been_bought'
     AND t.customerID IS NOT NULL  --  Only include sold tickets
    WHERE rdal.routeID = p_routeID
    GROUP BY bs.BusScheduleID, rdal.expectedProfit, bs.expectedProfit
    ORDER BY bs.BusScheduleID;

  -- Constants
  v_cost CONSTANT NUMBER := 150;

BEGIN
  DBMS_OUTPUT.PUT_LINE(
    RPAD('RouteID', 10) || RPAD('RouteName', 20) || RPAD('RouteProfit', 14) ||
    RPAD('ScheduleID', 12) || RPAD('ScheduleProfit', 16) || RPAD('Cost', 6) ||
    RPAD('Revenue', 10) || RPAD('Profit', 10) || RPAD('Result', 15)
  );

  FOR route_rec IN c_routes LOOP
    FOR sched_rec IN c_schedules(route_rec.routeID) LOOP
      -- Calculate profit and result
      DECLARE
        v_profit NUMBER;
        v_result VARCHAR2(20);
      BEGIN
        v_profit := sched_rec.actualRevenue - v_cost;
        IF v_profit >= sched_rec.scheduleExpectedProfit THEN
          v_result := 'Profitable';
        ELSE
          v_result := 'Underperformed';
        END IF;

        -- Print route info only once
        IF v_lastRouteID IS NULL OR v_lastRouteID != route_rec.routeID THEN
          DBMS_OUTPUT.PUT_LINE(
            RPAD(route_rec.routeID, 10) ||
            RPAD(route_rec.routeName, 20) ||
            RPAD(TO_CHAR(sched_rec.routeExpectedProfit, '999999.99'), 14)
          );
          v_lastRouteID := route_rec.routeID;
        ELSE
          DBMS_OUTPUT.PUT_LINE(RPAD(' ', 44)); -- skip repeating route info
        END IF;

        -- Print schedule info
        DBMS_OUTPUT.PUT_LINE(
          RPAD(sched_rec.BusScheduleID, 12) ||
          RPAD(TO_CHAR(sched_rec.scheduleExpectedProfit, '999999.99'), 16) ||
          RPAD(TO_CHAR(v_cost), 6) ||
          RPAD(TO_CHAR(sched_rec.actualRevenue, '999999.99'), 10) ||
          RPAD(TO_CHAR(v_profit, '999999.99'), 10) ||
          RPAD(v_result, 15)
        );
      END;
    END LOOP;
  END LOOP;
END;
/



2. Delayed Trip Root Cause Analysis Report -- accept a router id as input and check the related bus schedules delay count to find out on which day(bus schedule) the delay happened most frequently. range in month ;

📄 報告名稱：路線班次延遲與跳站分析報告（智慧型彙總版本）

輸入參數：
- routeID（欲分析的單一路線 ID）

輸出內容（分為兩個區塊）：
────────────────────────────────────────────
【Report A】路線延遲與跳站摘要

統計指標：
- 路線名稱（routeName）：由 Route 表查得
- 總班次數（totalSchedules）
- 有延遲紀錄的班次數（delayedSchedules）
- 跳站總次數（總共多少筆 Skipped 記錄）
- 最常見的延遲原因（Top Delay Reason）
- 最常見的跳站原因（Top Skip Reason）

資料來源：
- BusSchedule（根據 routeID 查所有班次）
- TripStopLog（透過 BusScheduleID 取得每筆班次的行車紀錄）
  - status = 'Delayed' 表示該站點延遲
  - status = 'Skipped' 表示該站點跳站
────────────────────────────────────────────
【Report B】延遲 / 跳站最嚴重的 Top 5 班次明細

排序條件：
- 根據 (delayCount + skipCount) 加總由高到低排序

每筆班次需列出：
- BusScheduleID
- 延遲次數（delayCount）
- 跳站次數（skipCount）
- 延遲總時長（delayTotalMinutes）
- 延遲與跳站原因摘要（remarks）：由 TripStopLog.remark 串接整理

最多顯示 5 筆記錄

────────────────────────────────────────────
🧭 資料流程邏輯說明：

Step 1：查詢輸入 routeID 對應的 routeName
- 由 Route 表取得 routeName

Step 2：彙總此路線下所有 BusSchedule 資料
- 計算：
  - totalSchedules（班次總數）
  - delayedSchedules（至少有一筆 TripStopLog status = 'Delayed' 的班次數）
  - 總跳站次數（TripStopLog status = 'Skipped' 的總筆數）
  - 出現頻率最高的 delay reason 與 skip reason（GROUP BY remark）

Step 3：逐筆處理所有 BusSchedule 班次
- 查詢 TripStopLog，條件為：TripStopLog.BusScheduleID = 當前班次 ID
- 統計：
  - 延遲次數 delayCount（status = 'Delayed'）
  - 跳站次數 skipCount（status = 'Skipped'）
  - 延遲總時長 delayTotalMinutes（actualDepartureTime - actualArrivalTime 累加）
  - 備註 remark 字串合併（收集所有與延遲 / 跳站有關的文字說明）

Step 4：排序找出前五名嚴重班次
- 根據 (delayCount + skipCount) 降序排序
- 最多取出前 5 筆，作為 Report B 輸出

Step 5：資料格式整理與輸出
- 結果可依照 BusScheduleID 排序
- 字段使用 TO_CHAR、RPAD 等對齊格式處理

CREATE OR REPLACE PROCEDURE GenerateSmartDelayReport_CursorStyle(
  p_routeID IN NUMBER
) IS
  -- Route Info
  CURSOR c_route IS
    SELECT routeID, routeName FROM Route WHERE routeID = p_routeID;

  -- Schedule Info
  CURSOR c_schedule(p_routeID NUMBER) IS
    SELECT bs.BusScheduleID, TRUNC(bs.plannedDepartureTime) AS schedDate
    FROM BusSchedule bs
    JOIN RouteDriverAssignmentList rdal
      ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    WHERE rdal.routeID = p_routeID;

  -- Delay/Skip Log
  CURSOR c_tripLog(p_scheduleID NUMBER) IS
    SELECT status, remarks,
           ROUND((actualDepartureTime - actualArrivalTime) * 24 * 60) AS duration
    FROM TripStopLog
    WHERE BusScheduleID = p_scheduleID;

  -- Variables
  v_routeID Route.routeID%TYPE;
  v_routeName Route.routeName%TYPE;
  v_schedID BusSchedule.BusScheduleID%TYPE;
  v_schedDate DATE;
  v_delayCount NUMBER;
  v_skipCount NUMBER;
  v_delayMins NUMBER;
  v_delayReasons CLOB;
  v_skipReasons CLOB;
  v_index NUMBER := 0;

  -- Summary
  v_totalSchedules NUMBER := 0;
  v_totalDelayedSchedules NUMBER := 0;
  v_totalSkippedStops NUMBER := 0;
  v_topDelayReason VARCHAR2(200);
  v_topSkipReason VARCHAR2(200);

BEGIN
  -- ===== ROUTE VALIDATION =====
  OPEN c_route;
  FETCH c_route INTO v_routeID, v_routeName;
  IF c_route%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE('Error: Invalid route ID: ' || p_routeID);
    RETURN;
  END IF;
  CLOSE c_route;

  -- ===== Summary Counts =====
  SELECT COUNT(*) INTO v_totalSchedules
  FROM BusSchedule bs
  JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE rdal.routeID = p_routeID;

  SELECT COUNT(DISTINCT tsl.BusScheduleID)
  INTO v_totalDelayedSchedules
  FROM TripStopLog tsl
  JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
  JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE rdal.routeID = p_routeID AND tsl.status = 'Delayed';

  SELECT COUNT(*)
  INTO v_totalSkippedStops
  FROM TripStopLog tsl
  JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
  JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE rdal.routeID = p_routeID AND tsl.status = 'Skipped';

  BEGIN
    SELECT remarks INTO v_topDelayReason
    FROM (
      SELECT remarks FROM TripStopLog tsl
      JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
      JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
      WHERE rdal.routeID = p_routeID AND tsl.status = 'Delayed' AND remarks IS NOT NULL
      GROUP BY remarks ORDER BY COUNT(*) DESC
    ) WHERE ROWNUM = 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_topDelayReason := 'N/A';
  END;

  BEGIN
    SELECT remarks INTO v_topSkipReason
    FROM (
      SELECT remarks FROM TripStopLog tsl
      JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
      JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
      WHERE rdal.routeID = p_routeID AND tsl.status = 'Skipped' AND remarks IS NOT NULL
      GROUP BY remarks ORDER BY COUNT(*) DESC
    ) WHERE ROWNUM = 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_topSkipReason := 'N/A';
  END;

  -- ===== OUTPUT HEADER =====
  DBMS_OUTPUT.PUT_LINE('Route Summary');
  DBMS_OUTPUT.PUT_LINE('-------------');
  DBMS_OUTPUT.PUT_LINE('Route ID           : ' || v_routeID);
  DBMS_OUTPUT.PUT_LINE('Route Name         : ' || v_routeName);
  DBMS_OUTPUT.PUT_LINE('Total Schedules    : ' || v_totalSchedules);
  DBMS_OUTPUT.PUT_LINE('Delayed Schedules  : ' || v_totalDelayedSchedules);
  DBMS_OUTPUT.PUT_LINE('Skipped Stops      : ' || v_totalSkippedStops);
  DBMS_OUTPUT.PUT_LINE('Top Delay Reason   : ' || v_topDelayReason);
  DBMS_OUTPUT.PUT_LINE('Top Skip Reason    : ' || v_topSkipReason);
  DBMS_OUTPUT.PUT_LINE('');

  -- ===== TOP 5 DETAILED =====
  DBMS_OUTPUT.PUT_LINE('Top 5 Problematic BusSchedules');
  DBMS_OUTPUT.PUT_LINE('-------------------------------');

  OPEN c_schedule(p_routeID);
  LOOP
    FETCH c_schedule INTO v_schedID, v_schedDate;
    EXIT WHEN c_schedule%NOTFOUND;

    -- reset counters
    v_delayCount := 0;
    v_skipCount := 0;
    v_delayMins := 0;
    v_delayReasons := '';
    v_skipReasons := '';

    FOR logRec IN c_tripLog(v_schedID) LOOP
      IF logRec.status = 'Delayed' THEN
        v_delayCount := v_delayCount + 1;
        v_delayMins := v_delayMins + NVL(logRec.duration, 0);
        v_delayReasons := v_delayReasons || NVL(logRec.remarks, '') || '; ';
      ELSIF logRec.status = 'Skipped' THEN
        v_skipCount := v_skipCount + 1;
        v_skipReasons := v_skipReasons || NVL(logRec.remarks, '') || '; ';
      END IF;
    END LOOP;

    -- Only show if there's a problem
    IF v_delayCount + v_skipCount > 0 AND v_index < 5 THEN
      v_index := v_index + 1;
      DBMS_OUTPUT.PUT_LINE('Schedule ID     : ' || v_schedID);
      DBMS_OUTPUT.PUT_LINE('Departure Date  : ' || TO_CHAR(v_schedDate, 'YYYY-MM-DD'));
      DBMS_OUTPUT.PUT_LINE('Delay Count     : ' || v_delayCount);
      DBMS_OUTPUT.PUT_LINE('Skip Count      : ' || v_skipCount);
      DBMS_OUTPUT.PUT_LINE('Delay Minutes   : ' || v_delayMins);
      DBMS_OUTPUT.PUT_LINE('Delay Reasons   : ' || v_delayReasons);
      DBMS_OUTPUT.PUT_LINE('Skip Reasons    : ' || v_skipReasons);
      DBMS_OUTPUT.PUT_LINE('---------------------------------------------');
    END IF;
  END LOOP;
  CLOSE c_schedule;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error: ' || SQLERRM);
END;
/



need a time script when the current time compare to ticket created time < 7 days (optional), then update the ticket status update to regular from booking.
add : trigger to execute this procedural every day at midnight.

CREATE OR REPLACE PROCEDURE UpdateBookingTickets IS
BEGIN
  UPDATE BusScheduleTicket
  SET status = 'regular'
  WHERE status = 'booking'
    AND createdAt < SYSDATE - 7; 
END;




sqlplus hy/hy123@localhost:1521/xepdb1