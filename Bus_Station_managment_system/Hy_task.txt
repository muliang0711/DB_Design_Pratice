è¼¸å…¥ï¼šp_scheduleIDï¼ˆä½ è¦ç”¢ç”Ÿç¥¨çš„ BusScheduleIDï¼‰

1. æŸ¥å‡ºè©² BusSchedule å°æ‡‰çš„ RouteDriverAssignmentList.assignmentIDï¼ˆå¸æ©Ÿä»»å‹™ï¼‰ã€
   ç­æ¬¡å»ºç«‹æ™‚é–“ï¼ˆcreatedAtï¼‰èˆ‡é å®šå‡ºç™¼æ™‚é–“ï¼ˆplannedDepartureTimeï¼‰ã€‚

2. æ ¹æ“š assignmentID æŸ¥å‡ºå°æ‡‰çš„ DriverListAssignment â†’ å–å¾— busIDï¼ˆè©²ç­æ¬¡æ‰€ä½¿ç”¨çš„å·´å£« IDï¼‰ã€‚

3. æ ¹æ“š busID æŸ¥å‡º Bus è³‡æ–™ â†’ å–å¾—å·´å£«çš„å®¹é‡ï¼ˆå³åº§ä½æ•¸ï¼‰ã€‚

4. é–‹å•Ÿä¸€å€‹ nested cursorï¼ˆå…§å±¤æ¸¸æ¨™ï¼‰ï¼Œå¾ 1 åˆ° capacityï¼Œå°æ¯å€‹åº§ä½é€²è¡Œä»¥ä¸‹æ“ä½œï¼š
   - ç”¢ç”Ÿåº§ä½ç·¨è™Ÿï¼ˆseatNoï¼‰ï¼šæ ¼å¼ç‚º `BUS<busID>-A<åº§ä½è™Ÿ>`ï¼Œä¾‹å¦‚ `BUS12-A1`
   - åˆ¤æ–·å‡ºç™¼æ™‚é–“ï¼ˆplannedDepartureTimeï¼‰æ˜¯å¦åœ¨ 7 å¤©å¾Œï¼š
     - å¦‚æœåœ¨ 7 å¤©å¾Œï¼Œå‰‡ç¥¨çš„ç‹€æ…‹ç‚º `'booking'`
     - å¦å‰‡ç‚º `'regular'`
   - å°‡ä»¥ä¸Šè³‡è¨Šæ’å…¥ Ticket è¡¨ä¸­ï¼ˆcustomerID ç‚º NULLï¼Œä»£è¡¨å°šæœªè³¼ç¥¨ï¼‰

5. æ¯ä¸€å¼µç¥¨çš„ç”¢ç”Ÿéƒ½åŒ…åœ¨ `EXCEPTION` å€å¡Šä¸­ï¼Œä»¥é˜²æ­¢æŸäº›åº§ä½æ’å…¥å¤±æ•—å°è‡´æ•´é«”ç¨‹åºçµ‚æ­¢ã€‚

CREATE OR REPLACE PROCEDURE GenerateTicketsForBusSchedule(p_scheduleID IN NUMBER) IS
  -- Variables
  v_assignmentID   DriverListAssignment.assignmentID%TYPE;
  v_busID          Bus.busID%TYPE;
  v_capacity       Bus.capacity%TYPE;
  v_createdAt      BusSchedule.createdAt%TYPE;
  v_departureTime  BusSchedule.plannedDepartureTime%TYPE;

  -- Cursor to simulate step-by-step extraction
  CURSOR c_schedule IS
    SELECT rdal.assignmentID, bs.createdAt, bs.plannedDepartureTime
    FROM BusSchedule bs
    JOIN RouteDriverAssignmentList rdal
      ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    WHERE bs.BusScheduleID = p_scheduleID;

  -- Cursor to simulate ticket generation for each seat
  CURSOR c_seatCapacity(p_capacity NUMBER) IS
    SELECT LEVEL AS seat_no FROM dual CONNECT BY LEVEL <= p_capacity;

BEGIN
  -- Outer cursor (simulate scan)
  FOR sched IN c_schedule LOOP
    BEGIN
      -- Step 1: Save values
      v_assignmentID := sched.assignmentID;
      v_createdAt := sched.createdAt;
      v_departureTime := sched.plannedDepartureTime;

      -- Step 2: Lookup busID from DriverListAssignment
      BEGIN
        SELECT busID INTO v_busID
        FROM DriverListAssignment
        WHERE assignmentID = v_assignmentID;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('No assignment found for assignmentID: ' || v_assignmentID);
          RETURN;
        WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Error getting busID: ' || SQLERRM);
          RETURN;
      END;

      -- Step 3: Get bus capacity
      BEGIN
        SELECT capacity INTO v_capacity
        FROM Bus
        WHERE busID = v_busID;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('No bus found for busID: ' || v_busID);
          RETURN;
        WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Error getting bus capacity: ' || SQLERRM);
          RETURN;
      END;

      -- Step 4: Loop through each seat using nested cursor
      FOR seat IN c_seatCapacity(v_capacity) LOOP
        BEGIN
          INSERT INTO Ticket (
            ticketID, BusScheduleID, customerID, seatNo, type, createdAt
          ) VALUES (
            Ticket_seq.NEXTVAL,
            p_scheduleID,
            NULL, -- No customer assigned yet
            'BUS' || v_busID || '-A' || TO_CHAR(seat.seat_no),
            CASE
              WHEN v_departureTime > SYSDATE + 7 THEN 'booking'
              ELSE 'regular'
            END,
            SYSDATE
          );
        EXCEPTION
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Failed to insert ticket for seat ' || seat.seat_no || ': ' || SQLERRM);
        END;
      END LOOP;

      DBMS_OUTPUT.PUT_LINE('Tickets generated for BusScheduleID: ' || p_scheduleID);
    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('General error during schedule processing: ' || SQLERRM);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error in outer block: ' || SQLERRM);
END;
/


/
CREATE OR REPLACE TRIGGER trg_create_tickets_on_planned
AFTER UPDATE OF status ON BusSchedule
FOR EACH ROW
WHEN (OLD.status = 'Pending' AND NEW.status = 'Planned')
BEGIN
  GenerateTicketsForBusSchedule(:NEW.BusScheduleID);
END;
/

Trigger : detect when a BusSchedule is set to Planned and auto-generate tickets.

CREATE OR REPLACE TRIGGER trg_create_tickets_on_planned
AFTER UPDATE OF status ON BusSchedule
FOR EACH ROW
WHEN (OLD.status = 'Pending' AND NEW.status = 'Planned')
BEGIN
  -- Call the stored procedure to generate tickets
  GenerateTicketsForBusSchedule(:NEW.BusScheduleID);
END;
/


è¼¸å…¥ï¼šdaysAheadï¼ˆå¾€å¾Œå¹¾å¤©ï¼Œè‡ªå‹•ç”¢ç”Ÿçš„ç­æ¬¡æ•¸ï¼‰

1. é–‹ä¸€å€‹æ¸¸æ¨™è®€å–æ‰€æœ‰å•Ÿç”¨ç‹€æ…‹ï¼ˆstatus = 'active'ï¼‰çš„ RouteDriverAssignmentListï¼Œ
   ä¸¦ä¸” JOIN Route ä»¥å–å¾—åŸå§‹çš„å‡ºç™¼èˆ‡æŠµé”æ™‚é–“ï¼Œ
   JOIN DriverListAssignment ä»¥å–å¾—å°æ‡‰çš„ driverID å’Œå…¶ assign æ™‚é–“ç¯„åœï¼ˆassignedFrom / assignedToï¼‰ã€‚

2. å°æ–¼ä»Šå¤©èµ·æ¥ä¸‹ä¾†çš„æ¯ä¸€å¤©ï¼ˆ0 åˆ° daysAheadï¼‰ï¼š
   - å–å‡ºä»Šå¤©çš„æ˜ŸæœŸå¹¾ï¼ˆ1=æ˜ŸæœŸæ—¥ï¼Œä¾æ“š NLS_TERRITORY è€Œå®šï¼‰
   - æª¢æŸ¥ç•¶å¤©çš„æ˜ŸæœŸå¹¾æ˜¯å¦åŒ…å«åœ¨è©²æ’ç­çš„ weekdays è¨­å®šä¸­ã€‚
   - æª¢æŸ¥ç•¶å¤©æ˜¯å¦åœ¨è©² RouteDriverAssignment çš„æœ‰æ•ˆæœŸé–“ï¼ˆeffectiveFrom ~ effectiveToï¼‰å…§ã€‚
   - æª¢æŸ¥ç•¶å¤©æ˜¯å¦åœ¨è©² driver çš„æŒ‡æ´¾æœŸé–“ï¼ˆassignedFrom ~ assignedToï¼‰å…§ã€‚
     â†’ è‹¥ä¸åœ¨æŒ‡æ´¾æœŸé–“ï¼Œè·³éè©²ç­†è³‡æ–™ï¼ˆè©²å¤©æœªè¢«æŒ‡æ´¾ï¼‰ã€‚

3. å¦‚æœä»¥ä¸Šæ¢ä»¶éƒ½ç¬¦åˆï¼š
   - æ ¹æ“šè©²å¤©çš„æ—¥æœŸ + åŸå§‹è¨­å®šçš„å‡ºç™¼èˆ‡æŠµé”æ™‚é–“ï¼Œçµ„æˆå®Œæ•´çš„ timestampã€‚
     ä¾‹å¦‚ï¼š2025-07-20 + 08:00 â†’ 2025-07-20 08:00:00
   - æª¢æŸ¥æ˜¯å¦å·²æœ‰é‡è¤‡çš„ BusScheduleï¼ˆä»¥ routeDriverAssignmentID + plannedDepartureTime ç‚ºå”¯ä¸€éµï¼‰ã€‚
     â†’ è‹¥å·²å­˜åœ¨ï¼Œè·³éä¸è™•ç†ã€‚
   - è‹¥æ²’æœ‰é‡è¤‡ï¼š
     - æ’å…¥ä¸€ç­†æ–°çš„ BusScheduleã€‚
     - è¨­å®šç‹€æ…‹ç‚º `Pending`ã€‚
     - èªªæ˜ï¼ˆremarksï¼‰å¡«å…¥ `Auto-generated by recurring assignment`ã€‚

CREATE OR REPLACE PROCEDURE GenerateBusSchedulesFromRecurring(daysAhead IN NUMBER) IS
  -- Outer cursor: active recurring assignments + route time + driver ID
  CURSOR c_recurring IS
    SELECT 
      rdal.*, 
      r.plannedDepartureTime, 
      r.plannedArrivalTime, 
      dla.driverID
    FROM RouteDriverAssignmentList rdal
    JOIN Route r ON r.routeID = rdal.routeID
    JOIN DriverListAssignment dla ON rdal.assignmentID = dla.assignmentID
    WHERE rdal.status = 'active';

  -- Nested cursor: check if driver is assigned to bus on that date
  CURSOR c_driverCheck(p_driverID NUMBER, p_date DATE) IS
    SELECT assignmentID
    FROM DriverListAssignment
    WHERE driverID = p_driverID
      AND TRUNC(p_date) BETWEEN TRUNC(assignedFrom) AND TRUNC(NVL(assignedTo, p_date));

  -- Variables
  v_date       DATE;
  v_weekday    VARCHAR2(1);
  v_dep        TIMESTAMP;
  v_arr        TIMESTAMP;
  rec          c_recurring%ROWTYPE;
  v_exists     NUMBER;
  v_dummy      DriverListAssignment.assignmentID%TYPE;

BEGIN
  FOR i IN 0 .. daysAhead LOOP
    BEGIN
      v_date := TRUNC(SYSDATE) + i;
      v_weekday := TO_CHAR(v_date, 'D'); -- 1 = Sunday (depends on NLS_TERRITORY)

      OPEN c_recurring;
      LOOP
        FETCH c_recurring INTO rec;
        EXIT WHEN c_recurring%NOTFOUND;

        BEGIN
          -- Check weekday match and effective date range
          IF v_date BETWEEN rec.effectiveFrom AND NVL(rec.effectiveTo, v_date)
             AND INSTR(',' || rec.weekdays || ',', ',' || v_weekday || ',') > 0 THEN

            -- Construct full timestamps for departure and arrival
            v_dep := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedDepartureTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');
            v_arr := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedArrivalTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');

            -- âœ… Check if the driver IS assigned to the bus on this day
            OPEN c_driverCheck(rec.driverID, v_date);
            FETCH c_driverCheck INTO v_dummy;
            IF NOT c_driverCheck%FOUND THEN
              DBMS_OUTPUT.PUT_LINE('Driver ' || rec.driverID || ' is not assigned to any bus on ' || TO_CHAR(v_date));
              CLOSE c_driverCheck;
              CONTINUE; -- Skip this assignment
            END IF;
            CLOSE c_driverCheck;

            -- Check for existing schedule (avoid duplicates)
            SELECT COUNT(*) INTO v_exists
            FROM BusSchedule
            WHERE routeDriverAssignmentID = rec.routeDriverAssignmentID
              AND plannedDepartureTime = v_dep;

            -- Insert new schedule if not exists
            IF v_exists = 0 THEN
              INSERT INTO BusSchedule (
                BusScheduleID, routeDriverAssignmentID, plannedDepartureTime, plannedArrivalTime,
                status, remarks, createdAt, updatedAt
              ) VALUES (
                BusSchedule_seq.NEXTVAL,
                rec.routeDriverAssignmentID,
                v_dep,
                v_arr,
                'Pending',
                'Auto-generated by recurring assignment',
                SYSDATE,
                SYSDATE
              );
              DBMS_OUTPUT.PUT_LINE('âœ… Inserted BusSchedule on ' || TO_CHAR(v_dep, 'YYYY-MM-DD HH24:MI'));
            ELSE
              DBMS_OUTPUT.PUT_LINE('âš ï¸ Duplicate found for ' || TO_CHAR(v_dep, 'YYYY-MM-DD HH24:MI'));
            END IF;

          END IF;

        EXCEPTION
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âŒ Error in assignment ID ' || rec.routeDriverAssignmentID || ': ' || SQLERRM);
        END;

      END LOOP;
      CLOSE c_recurring;

    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('âŒ Error processing day ' || TO_CHAR(v_date, 'YYYY-MM-DD') || ': ' || SQLERRM);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('ğŸš¨ Unexpected error in procedure: ' || SQLERRM);
END;
/




Trigger : auto generate BusSchedules from recurring assignments

BEGIN
  DBMS_SCHEDULER.create_job (
    job_name        => 'JOB_GENERATE_BUSES',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'GenerateBusSchedulesFromRecurring',
    number_of_arguments => 1,
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=00;BYMINUTE=00',
    enabled         => FALSE
  );

  -- Set daysAhead = 7
  DBMS_SCHEDULER.set_job_argument_value('JOB_GENERATE_BUSES', 1, 7);

  DBMS_SCHEDULER.enable('JOB_GENERATE_BUSES');
END;
/

we need a script to auto-update all the BusSchedule status to planned from pending when it being auto-generated.

CREATE OR REPLACE PROCEDURE UpdatePendingSchedulesToPlanned IS
  CURSOR pending_cursor IS
    SELECT BusScheduleID
    FROM BusSchedule
    WHERE status = 'Pending';
  v_scheduleID NUMBER;
BEGIN
  FOR rec IN pending_cursor LOOP
    v_scheduleID := rec.BusScheduleID;

    -- Update status to Planned
    UPDATE BusSchedule
    SET status = 'Planned',
        updatedAt = SYSDATE
    WHERE BusScheduleID = v_scheduleID;

    DBMS_OUTPUT.PUT_LINE('Updated BusScheduleID ' || v_scheduleID || ' to Planned.');
  END LOOP;
END;

two report : 
1. Route Profitability and Efficiency Report -- to decide drop or keep which route
SET PAGESIZE 1000
SET LINESIZE 200
COLUMN routeID FORMAT A10
COLUMN routeName FORMAT A20
COLUMN routeExpectedProfit FORMAT 999999.99
COLUMN scheduleID FORMAT A12
COLUMN scheduleExpectedProfit FORMAT 999999.99
COLUMN cost FORMAT 9999
COLUMN actualRevenue FORMAT 999999.99
COLUMN actualProfit FORMAT 999999.99
COLUMN scheduleResult FORMAT A20

WITH ScheduleProfit AS (
  SELECT
    r.routeID,
    r.routeName,
    rdal.expectedProfit AS routeExpectedProfit,
    bs.BusScheduleID AS scheduleID,
    bs.expectedProfit AS scheduleExpectedProfit,
    150 AS cost,
    COALESCE(SUM(t.price), 0) AS actualRevenue,
    (COALESCE(SUM(t.price), 0) - 150) AS actualProfit,
    CASE 
      WHEN (COALESCE(SUM(t.price), 0) - 150) >= bs.expectedProfit THEN 'âœ… Profitable'
      ELSE ' Underperformed'
    END AS scheduleResult,
    ROW_NUMBER() OVER (PARTITION BY r.routeID ORDER BY bs.BusScheduleID) AS rowNum
  FROM Route r
  JOIN RouteDriverAssignmentList rdal ON r.routeID = rdal.routeID
  JOIN BusSchedule bs ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  LEFT JOIN Ticket t ON t.BusScheduleID = bs.BusScheduleID AND t.status IS NULL
  GROUP BY r.routeID, r.routeName, rdal.expectedProfit, bs.BusScheduleID, bs.expectedProfit
)

SELECT
  CASE WHEN rowNum = 1 THEN routeID ELSE NULL END AS routeID,
  CASE WHEN rowNum = 1 THEN routeName ELSE NULL END AS routeName,
  CASE WHEN rowNum = 1 THEN routeExpectedProfit ELSE NULL END AS routeExpectedProfit,
  scheduleID,
  scheduleExpectedProfit,
  cost,
  actualRevenue,
  actualProfit,
  scheduleResult
FROM ScheduleProfit
ORDER BY routeID, scheduleID;

2. Delayed Trip Root Cause Analysis Report -- find out which trip have most delays and analyze the reasons for those delays to improve scheduling.


need a time script when the current time compare to ticket created time < 7 days (optional), then update the ticket status update to regular from booking.
add : trigger to execute this procedural every day at midnight.

CREATE OR REPLACE PROCEDURE UpdateBookingTickets IS
BEGIN
  UPDATE BusScheduleTicket
  SET status = 'regular'
  WHERE status = 'booking'
    AND createdAt < SYSDATE - 7; 
END;