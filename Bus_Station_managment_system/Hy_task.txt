è¼¸å…¥ï¼šp_scheduleIDï¼ˆä½ è¦ç”¢ç”Ÿç¥¨çš„ BusScheduleIDï¼‰

1. æŸ¥å‡ºè©² BusSchedule å°æ‡‰çš„ RouteDriverAssignmentList.assignmentIDï¼ˆå¸æ©Ÿä»»å‹™ï¼‰ã€
   ç­æ¬¡å»ºç«‹æ™‚é–“ï¼ˆcreatedAtï¼‰èˆ‡é å®šå‡ºç™¼æ™‚é–“ï¼ˆplannedDepartureTimeï¼‰ã€‚

2. æ ¹æ“š assignmentID æŸ¥å‡ºå°æ‡‰çš„ DriverListAssignment â†’ å–å¾— busIDï¼ˆè©²ç­æ¬¡æ‰€ä½¿ç”¨çš„å·´å£« IDï¼‰ã€‚

3. æ ¹æ“š busID æŸ¥å‡º Bus è³‡æ–™ â†’ å–å¾—å·´å£«çš„å®¹é‡ï¼ˆå³åº§ä½æ•¸ï¼‰ã€‚

4. é–‹å•Ÿä¸€å€‹ nested cursorï¼ˆå…§å±¤æ¸¸æ¨™ï¼‰ï¼Œå¾ 1 åˆ° capacityï¼Œå°æ¯å€‹åº§ä½é€²è¡Œä»¥ä¸‹æ“ä½œï¼š
   - ç”¢ç”Ÿåº§ä½ç·¨è™Ÿï¼ˆseatNoï¼‰ï¼šæ ¼å¼ç‚º `BUS<busID>-A<åº§ä½è™Ÿ>`ï¼Œä¾‹å¦‚ `BUS12-A1`
   - åˆ¤æ–·å‡ºç™¼æ™‚é–“ï¼ˆplannedDepartureTimeï¼‰æ˜¯å¦åœ¨ 7 å¤©å¾Œï¼š
     - å¦‚æœåœ¨ 7 å¤©å¾Œï¼Œå‰‡ç¥¨çš„ç‹€æ…‹ç‚º `'booking'`
     - å¦å‰‡ç‚º `'regular'`
   - å°‡ä»¥ä¸Šè³‡è¨Šæ’å…¥ Ticket è¡¨ä¸­ï¼ˆcustomerID ç‚º NULLï¼Œä»£è¡¨å°šæœªè³¼ç¥¨ï¼‰

5. æ¯ä¸€å¼µç¥¨çš„ç”¢ç”Ÿéƒ½åŒ…åœ¨ `EXCEPTION` å€å¡Šä¸­ï¼Œä»¥é˜²æ­¢æŸäº›åº§ä½æ’å…¥å¤±æ•—å°è‡´æ•´é«”ç¨‹åºçµ‚æ­¢ã€‚

CREATE OR REPLACE PROCEDURE GenerateTicketsForBusSchedule(p_scheduleID IN NUMBER) IS
  -- Variables
  v_assignmentID   DriverListAssignment.assignmentID%TYPE;
  v_busID          Bus.busID%TYPE;
  v_capacity       Bus.capacity%TYPE;
  v_createdAt      BusSchedule.createdAt%TYPE;
  v_departureTime  BusSchedule.plannedDepartureTime%TYPE;

  -- Cursor to simulate step-by-step extraction
  CURSOR c_schedule IS
    SELECT rdal.assignmentID, bs.createdAt, bs.plannedDepartureTime
    FROM BusSchedule bs
    JOIN RouteDriverAssignmentList rdal
      ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    WHERE bs.BusScheduleID = p_scheduleID;

  -- Cursor to simulate ticket generation for each seat
  CURSOR c_seatCapacity(p_capacity NUMBER) IS
    SELECT LEVEL AS seat_no FROM dual CONNECT BY LEVEL <= p_capacity;

BEGIN
  -- Outer cursor (simulate scan)
  FOR sched IN c_schedule LOOP
    BEGIN
      -- Step 1: Save values
      v_assignmentID := sched.assignmentID;
      v_createdAt := sched.createdAt;
      v_departureTime := sched.plannedDepartureTime;

      -- Step 2: Lookup busID from DriverListAssignment
      BEGIN
        SELECT busID INTO v_busID
        FROM DriverListAssignment
        WHERE assignmentID = v_assignmentID;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('No assignment found for assignmentID: ' || v_assignmentID);
          RETURN;
        WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Error getting busID: ' || SQLERRM);
          RETURN;
      END;

      -- Step 3: Get bus capacity
      BEGIN
        SELECT capacity INTO v_capacity
        FROM Bus
        WHERE busID = v_busID;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          DBMS_OUTPUT.PUT_LINE('No bus found for busID: ' || v_busID);
          RETURN;
        WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Error getting bus capacity: ' || SQLERRM);
          RETURN;
      END;

      -- Step 4: Loop through each seat using nested cursor
      FOR seat IN c_seatCapacity(v_capacity) LOOP
        BEGIN
          INSERT INTO Ticket (
            ticketID, BusScheduleID, customerID, seatNo, type, createdAt
          ) VALUES (
            Ticket_seq.NEXTVAL,
            p_scheduleID,
            NULL, -- No customer assigned yet
            'BUS' || v_busID || '-A' || TO_CHAR(seat.seat_no),
            CASE
              WHEN v_departureTime > SYSDATE + 7 THEN 'booking'
              ELSE 'regular'
            END,
            SYSDATE
          );
        EXCEPTION
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Failed to insert ticket for seat ' || seat.seat_no || ': ' || SQLERRM);
        END;
      END LOOP;

      DBMS_OUTPUT.PUT_LINE('Tickets generated for BusScheduleID: ' || p_scheduleID);
    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('General error during schedule processing: ' || SQLERRM);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error in outer block: ' || SQLERRM);
END;
/


/
Trigger : detect when a BusSchedule is set to Planned and auto-generate tickets.

CREATE OR REPLACE TRIGGER trg_create_tickets_on_planned
AFTER UPDATE OF status ON BusSchedule
FOR EACH ROW
WHEN (OLD.status = 'Pending' AND NEW.status = 'Planned')
BEGIN
  GenerateTicketsForBusSchedule(:NEW.BusScheduleID);
  -- if 
  -- commit 
  -- else 
  -- rollback 
  -- show error message
END;
/


è¼¸å…¥ï¼šdaysAheadï¼ˆå¾€å¾Œå¹¾å¤©ï¼Œè‡ªå‹•ç”¢ç”Ÿçš„ç­æ¬¡æ•¸ï¼‰

1. é–‹ä¸€å€‹æ¸¸æ¨™è®€å–æ‰€æœ‰å•Ÿç”¨ç‹€æ…‹ï¼ˆstatus = 'active'ï¼‰çš„ RouteDriverAssignmentListï¼Œ
   ä¸¦ä¸” JOIN Route ä»¥å–å¾—åŸå§‹çš„å‡ºç™¼èˆ‡æŠµé”æ™‚é–“ï¼Œ
   JOIN DriverListAssignment ä»¥å–å¾—å°æ‡‰çš„ driverID å’Œå…¶ assign æ™‚é–“ç¯„åœï¼ˆassignedFrom / assignedToï¼‰ã€‚

2. å°æ–¼ä»Šå¤©èµ·æ¥ä¸‹ä¾†çš„æ¯ä¸€å¤©ï¼ˆ0 åˆ° daysAheadï¼‰ï¼š
   - å–å‡ºä»Šå¤©çš„æ˜ŸæœŸå¹¾ï¼ˆ1=æ˜ŸæœŸæ—¥ï¼Œä¾æ“š NLS_TERRITORY è€Œå®šï¼‰
   - æª¢æŸ¥ç•¶å¤©çš„æ˜ŸæœŸå¹¾æ˜¯å¦åŒ…å«åœ¨è©²æ’ç­çš„ weekdays è¨­å®šä¸­ã€‚
   - æª¢æŸ¥ç•¶å¤©æ˜¯å¦åœ¨è©² RouteDriverAssignment çš„æœ‰æ•ˆæœŸé–“ï¼ˆeffectiveFrom ~ effectiveToï¼‰å…§ã€‚
   - æª¢æŸ¥ç•¶å¤©æ˜¯å¦åœ¨è©² driver çš„æŒ‡æ´¾æœŸé–“ï¼ˆassignedFrom ~ assignedToï¼‰å…§ã€‚
     â†’ è‹¥ä¸åœ¨æŒ‡æ´¾æœŸé–“ï¼Œè·³éè©²ç­†è³‡æ–™ï¼ˆè©²å¤©æœªè¢«æŒ‡æ´¾ï¼‰ã€‚

3. å¦‚æœä»¥ä¸Šæ¢ä»¶éƒ½ç¬¦åˆï¼š
   - æ ¹æ“šè©²å¤©çš„æ—¥æœŸ + åŸå§‹è¨­å®šçš„å‡ºç™¼èˆ‡æŠµé”æ™‚é–“ï¼Œçµ„æˆå®Œæ•´çš„ timestampã€‚
     ä¾‹å¦‚ï¼š2025-07-20 + 08:00 â†’ 2025-07-20 08:00:00
   - æª¢æŸ¥æ˜¯å¦å·²æœ‰é‡è¤‡çš„ BusScheduleï¼ˆä»¥ routeDriverAssignmentID + plannedDepartureTime ç‚ºå”¯ä¸€éµï¼‰ã€‚
     â†’ è‹¥å·²å­˜åœ¨ï¼Œè·³éä¸è™•ç†ã€‚
   - è‹¥æ²’æœ‰é‡è¤‡ï¼š
     - æ’å…¥ä¸€ç­†æ–°çš„ BusScheduleã€‚
     - è¨­å®šç‹€æ…‹ç‚º `Pending`ã€‚
     - èªªæ˜ï¼ˆremarksï¼‰å¡«å…¥ `Auto-generated by recurring assignment`ã€‚

CREATE OR REPLACE PROCEDURE GenerateBusSchedulesFromRecurring(daysAhead IN NUMBER) IS
  -- Outer cursor: active recurring assignments + route time + driver ID
  CURSOR c_recurring IS
    SELECT 
      rdal.*, 
      r.plannedDepartureTime, 
      r.plannedArrivalTime, 
      dla.driverID
    FROM RouteDriverAssignmentList rdal
    JOIN Route r ON r.routeID = rdal.routeID
    JOIN DriverListAssignment dla ON rdal.assignmentID = dla.assignmentID
    WHERE rdal.status = 'active';

  -- Nested cursor: check if driver is assigned to bus on that date
  CURSOR c_driverCheck(p_driverID NUMBER, p_date DATE) IS
    SELECT assignmentID
    FROM DriverListAssignment
    WHERE driverID = p_driverID
      AND TRUNC(p_date) BETWEEN TRUNC(assignedFrom) AND TRUNC(NVL(assignedTo, p_date));

  -- Variables
  v_date       DATE;
  v_weekday    VARCHAR2(1);
  v_dep        TIMESTAMP;
  v_arr        TIMESTAMP;
  rec          c_recurring%ROWTYPE;
  v_exists     NUMBER;
  v_dummy      DriverListAssignment.assignmentID%TYPE;

BEGIN
  FOR i IN 0 .. daysAhead LOOP
    BEGIN
      v_date := TRUNC(SYSDATE) + i;
      v_weekday := TO_CHAR(v_date, 'D'); -- 1 = Sunday (depends on NLS_TERRITORY)

      OPEN c_recurring;
      LOOP
        FETCH c_recurring INTO rec;
        EXIT WHEN c_recurring%NOTFOUND;

        BEGIN
          -- Check weekday match and effective date range
          IF v_date BETWEEN rec.effectiveFrom AND NVL(rec.effectiveTo, v_date)
             AND INSTR(',' || rec.weekdays || ',', ',' || v_weekday || ',') > 0 THEN

            -- Construct full timestamps for departure and arrival
            v_dep := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedDepartureTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');
            v_arr := TO_TIMESTAMP(TO_CHAR(v_date, 'YYYY-MM-DD') || ' ' || TO_CHAR(rec.plannedArrivalTime, 'HH24:MI'), 'YYYY-MM-DD HH24:MI');

            -- Check if the driver IS assigned to the bus on this day
            OPEN c_driverCheck(rec.driverID, v_date);
            FETCH c_driverCheck INTO v_dummy;
            IF NOT c_driverCheck%FOUND THEN
              DBMS_OUTPUT.PUT_LINE('Driver ' || rec.driverID || ' is not assigned to any bus on ' || TO_CHAR(v_date));
              CLOSE c_driverCheck;
              CONTINUE; -- Skip this assignment
            END IF;
            CLOSE c_driverCheck;

            -- Check for existing schedule (avoid duplicates)
            SELECT COUNT(*) INTO v_exists
            FROM BusSchedule
            WHERE routeDriverAssignmentID = rec.routeDriverAssignmentID
              AND plannedDepartureTime = v_dep;

            -- Insert new schedule if not exists
            IF v_exists = 0 THEN
              INSERT INTO BusSchedule (
                BusScheduleID, routeDriverAssignmentID, plannedDepartureTime, plannedArrivalTime,
                status, remarks, createdAt, updatedAt
              ) VALUES (
                BusSchedule_seq.NEXTVAL,
                rec.routeDriverAssignmentID,
                v_dep,
                v_arr,
                'Pending',
                'Auto-generated by recurring assignment',
                SYSDATE,
                SYSDATE
              );
              DBMS_OUTPUT.PUT_LINE('Inserted BusSchedule on ' || TO_CHAR(v_dep, 'YYYY-MM-DD HH24:MI'));
            ELSE
              DBMS_OUTPUT.PUT_LINE('Duplicate found for ' || TO_CHAR(v_dep, 'YYYY-MM-DD HH24:MI'));
            END IF;

          END IF;

        EXCEPTION
          WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error in assignment ID ' || rec.routeDriverAssignmentID || ': ' || SQLERRM);
        END;

      END LOOP;
      CLOSE c_recurring;

    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error processing day ' || TO_CHAR(v_date, 'YYYY-MM-DD') || ': ' || SQLERRM);
    END;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error in procedure: ' || SQLERRM);
END;
/




Trigger : auto generate BusSchedules from recurring assignments

BEGIN
  DBMS_SCHEDULER.create_job (
    job_name        => 'JOB_GENERATE_BUSES',
    job_type        => 'STORED_PROCEDURE',
    job_action      => 'GenerateBusSchedulesFromRecurring',
    number_of_arguments => 1,
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=00;BYMINUTE=00',
    enabled         => FALSE
  );

  -- Set daysAhead = 7
  DBMS_SCHEDULER.set_job_argument_value('JOB_GENERATE_BUSES', 1, 7);
  -- if 
  -- commit
  -- else
  -- rollback
  -- enable the job
  DBMS_SCHEDULER.enable('JOB_GENERATE_BUSES');
END;
/

we need a script to auto-update all the BusSchedule status to planned from pending when it being auto-generated.

CREATE OR REPLACE PROCEDURE UpdatePendingSchedulesToPlanned IS
  CURSOR pending_cursor IS
    SELECT BusScheduleID
    FROM BusSchedule
    WHERE status = 'Pending';
  v_scheduleID NUMBER;
BEGIN
  FOR rec IN pending_cursor LOOP
    v_scheduleID := rec.BusScheduleID;

    -- Update status to Planned
    UPDATE BusSchedule
    SET status = 'Planned',
        updatedAt = SYSDATE
    WHERE BusScheduleID = v_scheduleID;

    DBMS_OUTPUT.PUT_LINE('Updated BusScheduleID ' || v_scheduleID || ' to Planned.');
  END LOOP;
END;

two report : 
1. Route Profitability and Efficiency Report -- to decide drop or keep which route

è¼¸å…¥ï¼šç„¡
è¼¸å‡ºï¼šåˆ—å°æ¯æ¢ Route ä¸‹çš„ BusSchedule èˆ‡åˆ©æ½¤è¡¨ç¾å ±å‘Š

1. é–‹å•Ÿå¤–å±¤æ¸¸æ¨™ï¼šå–å¾—æ‰€æœ‰ Route è³‡æ–™
   - routeID, routeName

2. å°æ–¼æ¯å€‹ routeID é–‹å•Ÿå…§å±¤æ¸¸æ¨™ï¼šæŠ“å–è©²è·¯ç·šä¸‹çš„ BusSchedules
   - åˆ©ç”¨ RouteDriverAssignmentList æ‰¾å‡º routeDriverAssignmentID
   - æ‰¾åˆ° BusSchedule ä¸¦ JOIN Ticket è¨ˆç®—å¯¦éš›ç‡Ÿæ”¶èˆ‡åˆ©æ½¤ When 
   - Ticket.status = 'been_bought'
   - Ticket.customerID IS NOT NULL

3. å°æ–¼æ¯ç­† BusScheduleï¼š
   - è¨ˆç®— SUM(price)ã€profit = revenue - 150
   - èˆ‡ expectedProfit æ¯”è¼ƒ â†’ æ±ºå®šçµæœï¼ˆProfitable / Underperformedï¼‰

4. æ¨¡æ“¬åˆ†çµ„é¡¯ç¤ºï¼šè‹¥ç‚ºæ–°çš„ route æ‰å°å‡º route è³‡è¨Š

5. è³‡æ–™æ ¼å¼åŒ–è¼¸å‡ºï¼ˆä½¿ç”¨ RPAD èˆ‡ TO_CHAR å°é½Šæ¬„ä½ï¼‰ï¼š
   æ¬„ä½åŒ…å«ï¼š
   - routeID
   - routeName
   - routeExpectedProfit
   - scheduleID
   - scheduleExpectedProfit
   - costï¼ˆå›ºå®š 150ï¼‰
   - actualRevenueï¼ˆç¸½ç¥¨åƒ¹ï¼‰
   - actualProfitï¼ˆå¯¦éš›åˆ©æ½¤ï¼‰
   - scheduleResultï¼ˆProfitable æˆ– Underperformedï¼‰


CREATE OR REPLACE PROCEDURE ReportRouteScheduleProfit_Nested IS
  -- Variable to track previous routeID
  v_lastRouteID Route.routeID%TYPE := NULL;

  -- Outer cursor: All routes
  CURSOR c_routes IS
    SELECT routeID, routeName FROM Route ORDER BY routeID;

  -- Inner cursor: BusSchedules under a specific route (only count sold tickets)
  CURSOR c_schedules(p_routeID Route.routeID%TYPE) IS
    SELECT 
      bs.BusScheduleID,
      rdal.expectedProfit AS routeExpectedProfit,
      bs.expectedProfit AS scheduleExpectedProfit,
      COALESCE(SUM(t.price), 0) AS actualRevenue
    FROM RouteDriverAssignmentList rdal
    JOIN BusSchedule bs ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    LEFT JOIN Ticket t 
      ON t.BusScheduleID = bs.BusScheduleID 
     AND t.status = 'been_bought'
     AND t.customerID IS NOT NULL  --  Only include sold tickets
    WHERE rdal.routeID = p_routeID
    GROUP BY bs.BusScheduleID, rdal.expectedProfit, bs.expectedProfit
    ORDER BY bs.BusScheduleID;

  -- Constants
  v_cost CONSTANT NUMBER := 150;

BEGIN
  DBMS_OUTPUT.PUT_LINE(
    RPAD('RouteID', 10) || RPAD('RouteName', 20) || RPAD('RouteProfit', 14) ||
    RPAD('ScheduleID', 12) || RPAD('ScheduleProfit', 16) || RPAD('Cost', 6) ||
    RPAD('Revenue', 10) || RPAD('Profit', 10) || RPAD('Result', 15)
  );

  FOR route_rec IN c_routes LOOP
    FOR sched_rec IN c_schedules(route_rec.routeID) LOOP
      -- Calculate profit and result
      DECLARE
        v_profit NUMBER;
        v_result VARCHAR2(20);
      BEGIN
        v_profit := sched_rec.actualRevenue - v_cost;
        IF v_profit >= sched_rec.scheduleExpectedProfit THEN
          v_result := 'Profitable';
        ELSE
          v_result := 'Underperformed';
        END IF;

        -- Print route info only once
        IF v_lastRouteID IS NULL OR v_lastRouteID != route_rec.routeID THEN
          DBMS_OUTPUT.PUT_LINE(
            RPAD(route_rec.routeID, 10) ||
            RPAD(route_rec.routeName, 20) ||
            RPAD(TO_CHAR(sched_rec.routeExpectedProfit, '999999.99'), 14)
          );
          v_lastRouteID := route_rec.routeID;
        ELSE
          DBMS_OUTPUT.PUT_LINE(RPAD(' ', 44)); -- skip repeating route info
        END IF;

        -- Print schedule info
        DBMS_OUTPUT.PUT_LINE(
          RPAD(sched_rec.BusScheduleID, 12) ||
          RPAD(TO_CHAR(sched_rec.scheduleExpectedProfit, '999999.99'), 16) ||
          RPAD(TO_CHAR(v_cost), 6) ||
          RPAD(TO_CHAR(sched_rec.actualRevenue, '999999.99'), 10) ||
          RPAD(TO_CHAR(v_profit, '999999.99'), 10) ||
          RPAD(v_result, 15)
        );
      END;
    END LOOP;
  END LOOP;
END;
/



2. Delayed Trip Root Cause Analysis Report -- accept a router id as input and check the related bus schedules delay count to find out on which day(bus schedule) the delay happened most frequently. range in month ;

ğŸ“„ å ±å‘Šåç¨±ï¼šè·¯ç·šç­æ¬¡å»¶é²èˆ‡è·³ç«™åˆ†æå ±å‘Šï¼ˆæ™ºæ…§å‹å½™ç¸½ç‰ˆæœ¬ï¼‰

è¼¸å…¥åƒæ•¸ï¼š
- routeIDï¼ˆæ¬²åˆ†æçš„å–®ä¸€è·¯ç·š IDï¼‰

è¼¸å‡ºå…§å®¹ï¼ˆåˆ†ç‚ºå…©å€‹å€å¡Šï¼‰ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€Report Aã€‘è·¯ç·šå»¶é²èˆ‡è·³ç«™æ‘˜è¦

çµ±è¨ˆæŒ‡æ¨™ï¼š
- è·¯ç·šåç¨±ï¼ˆrouteNameï¼‰ï¼šç”± Route è¡¨æŸ¥å¾—
- ç¸½ç­æ¬¡æ•¸ï¼ˆtotalSchedulesï¼‰
- æœ‰å»¶é²ç´€éŒ„çš„ç­æ¬¡æ•¸ï¼ˆdelayedSchedulesï¼‰
- è·³ç«™ç¸½æ¬¡æ•¸ï¼ˆç¸½å…±å¤šå°‘ç­† Skipped è¨˜éŒ„ï¼‰
- æœ€å¸¸è¦‹çš„å»¶é²åŸå› ï¼ˆTop Delay Reasonï¼‰
- æœ€å¸¸è¦‹çš„è·³ç«™åŸå› ï¼ˆTop Skip Reasonï¼‰

è³‡æ–™ä¾†æºï¼š
- BusScheduleï¼ˆæ ¹æ“š routeID æŸ¥æ‰€æœ‰ç­æ¬¡ï¼‰
- TripStopLogï¼ˆé€é BusScheduleID å–å¾—æ¯ç­†ç­æ¬¡çš„è¡Œè»Šç´€éŒ„ï¼‰
  - status = 'Delayed' è¡¨ç¤ºè©²ç«™é»å»¶é²
  - status = 'Skipped' è¡¨ç¤ºè©²ç«™é»è·³ç«™
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€Report Bã€‘å»¶é² / è·³ç«™æœ€åš´é‡çš„ Top 5 ç­æ¬¡æ˜ç´°

æ’åºæ¢ä»¶ï¼š
- æ ¹æ“š (delayCount + skipCount) åŠ ç¸½ç”±é«˜åˆ°ä½æ’åº

æ¯ç­†ç­æ¬¡éœ€åˆ—å‡ºï¼š
- BusScheduleID
- å»¶é²æ¬¡æ•¸ï¼ˆdelayCountï¼‰
- è·³ç«™æ¬¡æ•¸ï¼ˆskipCountï¼‰
- å»¶é²ç¸½æ™‚é•·ï¼ˆdelayTotalMinutesï¼‰
- å»¶é²èˆ‡è·³ç«™åŸå› æ‘˜è¦ï¼ˆremarksï¼‰ï¼šç”± TripStopLog.remark ä¸²æ¥æ•´ç†

æœ€å¤šé¡¯ç¤º 5 ç­†è¨˜éŒ„

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§­ è³‡æ–™æµç¨‹é‚è¼¯èªªæ˜ï¼š

Step 1ï¼šæŸ¥è©¢è¼¸å…¥ routeID å°æ‡‰çš„ routeName
- ç”± Route è¡¨å–å¾— routeName

Step 2ï¼šå½™ç¸½æ­¤è·¯ç·šä¸‹æ‰€æœ‰ BusSchedule è³‡æ–™
- è¨ˆç®—ï¼š
  - totalSchedulesï¼ˆç­æ¬¡ç¸½æ•¸ï¼‰
  - delayedSchedulesï¼ˆè‡³å°‘æœ‰ä¸€ç­† TripStopLog status = 'Delayed' çš„ç­æ¬¡æ•¸ï¼‰
  - ç¸½è·³ç«™æ¬¡æ•¸ï¼ˆTripStopLog status = 'Skipped' çš„ç¸½ç­†æ•¸ï¼‰
  - å‡ºç¾é »ç‡æœ€é«˜çš„ delay reason èˆ‡ skip reasonï¼ˆGROUP BY remarkï¼‰

Step 3ï¼šé€ç­†è™•ç†æ‰€æœ‰ BusSchedule ç­æ¬¡
- æŸ¥è©¢ TripStopLogï¼Œæ¢ä»¶ç‚ºï¼šTripStopLog.BusScheduleID = ç•¶å‰ç­æ¬¡ ID
- çµ±è¨ˆï¼š
  - å»¶é²æ¬¡æ•¸ delayCountï¼ˆstatus = 'Delayed'ï¼‰
  - è·³ç«™æ¬¡æ•¸ skipCountï¼ˆstatus = 'Skipped'ï¼‰
  - å»¶é²ç¸½æ™‚é•· delayTotalMinutesï¼ˆactualDepartureTime - actualArrivalTime ç´¯åŠ ï¼‰
  - å‚™è¨» remark å­—ä¸²åˆä½µï¼ˆæ”¶é›†æ‰€æœ‰èˆ‡å»¶é² / è·³ç«™æœ‰é—œçš„æ–‡å­—èªªæ˜ï¼‰

Step 4ï¼šæ’åºæ‰¾å‡ºå‰äº”ååš´é‡ç­æ¬¡
- æ ¹æ“š (delayCount + skipCount) é™åºæ’åº
- æœ€å¤šå–å‡ºå‰ 5 ç­†ï¼Œä½œç‚º Report B è¼¸å‡º

Step 5ï¼šè³‡æ–™æ ¼å¼æ•´ç†èˆ‡è¼¸å‡º
- çµæœå¯ä¾ç…§ BusScheduleID æ’åº
- å­—æ®µä½¿ç”¨ TO_CHARã€RPAD ç­‰å°é½Šæ ¼å¼è™•ç†

CREATE OR REPLACE PROCEDURE GenerateSmartDelayReport_CursorStyle(
  p_routeID IN NUMBER
) IS
  -- Route Info
  CURSOR c_route IS
    SELECT routeID, routeName FROM Route WHERE routeID = p_routeID;

  -- Schedule Info
  CURSOR c_schedule(p_routeID NUMBER) IS
    SELECT bs.BusScheduleID, TRUNC(bs.plannedDepartureTime) AS schedDate
    FROM BusSchedule bs
    JOIN RouteDriverAssignmentList rdal
      ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
    WHERE rdal.routeID = p_routeID;

  -- Delay/Skip Log
  CURSOR c_tripLog(p_scheduleID NUMBER) IS
    SELECT status, remarks,
           ROUND((actualDepartureTime - actualArrivalTime) * 24 * 60) AS duration
    FROM TripStopLog
    WHERE BusScheduleID = p_scheduleID;

  -- Variables
  v_routeID Route.routeID%TYPE;
  v_routeName Route.routeName%TYPE;
  v_schedID BusSchedule.BusScheduleID%TYPE;
  v_schedDate DATE;
  v_delayCount NUMBER;
  v_skipCount NUMBER;
  v_delayMins NUMBER;
  v_delayReasons CLOB;
  v_skipReasons CLOB;
  v_index NUMBER := 0;

  -- Summary
  v_totalSchedules NUMBER := 0;
  v_totalDelayedSchedules NUMBER := 0;
  v_totalSkippedStops NUMBER := 0;
  v_topDelayReason VARCHAR2(200);
  v_topSkipReason VARCHAR2(200);

BEGIN
  -- ===== ROUTE VALIDATION =====
  OPEN c_route;
  FETCH c_route INTO v_routeID, v_routeName;
  IF c_route%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE('Error: Invalid route ID: ' || p_routeID);
    RETURN;
  END IF;
  CLOSE c_route;

  -- ===== Summary Counts =====
  SELECT COUNT(*) INTO v_totalSchedules
  FROM BusSchedule bs
  JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE rdal.routeID = p_routeID;

  SELECT COUNT(DISTINCT tsl.BusScheduleID)
  INTO v_totalDelayedSchedules
  FROM TripStopLog tsl
  JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
  JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE rdal.routeID = p_routeID AND tsl.status = 'Delayed';

  SELECT COUNT(*)
  INTO v_totalSkippedStops
  FROM TripStopLog tsl
  JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
  JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
  WHERE rdal.routeID = p_routeID AND tsl.status = 'Skipped';

  BEGIN
    SELECT remarks INTO v_topDelayReason
    FROM (
      SELECT remarks FROM TripStopLog tsl
      JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
      JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
      WHERE rdal.routeID = p_routeID AND tsl.status = 'Delayed' AND remarks IS NOT NULL
      GROUP BY remarks ORDER BY COUNT(*) DESC
    ) WHERE ROWNUM = 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_topDelayReason := 'N/A';
  END;

  BEGIN
    SELECT remarks INTO v_topSkipReason
    FROM (
      SELECT remarks FROM TripStopLog tsl
      JOIN BusSchedule bs ON tsl.BusScheduleID = bs.BusScheduleID
      JOIN RouteDriverAssignmentList rdal ON bs.routeDriverAssignmentID = rdal.routeDriverAssignmentID
      WHERE rdal.routeID = p_routeID AND tsl.status = 'Skipped' AND remarks IS NOT NULL
      GROUP BY remarks ORDER BY COUNT(*) DESC
    ) WHERE ROWNUM = 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_topSkipReason := 'N/A';
  END;

  -- ===== OUTPUT HEADER =====
  DBMS_OUTPUT.PUT_LINE('Route Summary');
  DBMS_OUTPUT.PUT_LINE('-------------');
  DBMS_OUTPUT.PUT_LINE('Route ID           : ' || v_routeID);
  DBMS_OUTPUT.PUT_LINE('Route Name         : ' || v_routeName);
  DBMS_OUTPUT.PUT_LINE('Total Schedules    : ' || v_totalSchedules);
  DBMS_OUTPUT.PUT_LINE('Delayed Schedules  : ' || v_totalDelayedSchedules);
  DBMS_OUTPUT.PUT_LINE('Skipped Stops      : ' || v_totalSkippedStops);
  DBMS_OUTPUT.PUT_LINE('Top Delay Reason   : ' || v_topDelayReason);
  DBMS_OUTPUT.PUT_LINE('Top Skip Reason    : ' || v_topSkipReason);
  DBMS_OUTPUT.PUT_LINE('');

  -- ===== TOP 5 DETAILED =====
  DBMS_OUTPUT.PUT_LINE('Top 5 Problematic BusSchedules');
  DBMS_OUTPUT.PUT_LINE('-------------------------------');

  OPEN c_schedule(p_routeID);
  LOOP
    FETCH c_schedule INTO v_schedID, v_schedDate;
    EXIT WHEN c_schedule%NOTFOUND;

    -- reset counters
    v_delayCount := 0;
    v_skipCount := 0;
    v_delayMins := 0;
    v_delayReasons := '';
    v_skipReasons := '';

    FOR logRec IN c_tripLog(v_schedID) LOOP
      IF logRec.status = 'Delayed' THEN
        v_delayCount := v_delayCount + 1;
        v_delayMins := v_delayMins + NVL(logRec.duration, 0);
        v_delayReasons := v_delayReasons || NVL(logRec.remarks, '') || '; ';
      ELSIF logRec.status = 'Skipped' THEN
        v_skipCount := v_skipCount + 1;
        v_skipReasons := v_skipReasons || NVL(logRec.remarks, '') || '; ';
      END IF;
    END LOOP;

    -- Only show if there's a problem
    IF v_delayCount + v_skipCount > 0 AND v_index < 5 THEN
      v_index := v_index + 1;
      DBMS_OUTPUT.PUT_LINE('Schedule ID     : ' || v_schedID);
      DBMS_OUTPUT.PUT_LINE('Departure Date  : ' || TO_CHAR(v_schedDate, 'YYYY-MM-DD'));
      DBMS_OUTPUT.PUT_LINE('Delay Count     : ' || v_delayCount);
      DBMS_OUTPUT.PUT_LINE('Skip Count      : ' || v_skipCount);
      DBMS_OUTPUT.PUT_LINE('Delay Minutes   : ' || v_delayMins);
      DBMS_OUTPUT.PUT_LINE('Delay Reasons   : ' || v_delayReasons);
      DBMS_OUTPUT.PUT_LINE('Skip Reasons    : ' || v_skipReasons);
      DBMS_OUTPUT.PUT_LINE('---------------------------------------------');
    END IF;
  END LOOP;
  CLOSE c_schedule;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Unexpected error: ' || SQLERRM);
END;
/



need a time script when the current time compare to ticket created time < 7 days (optional), then update the ticket status update to regular from booking.
add : trigger to execute this procedural every day at midnight.

CREATE OR REPLACE PROCEDURE UpdateBookingTickets IS
BEGIN
  UPDATE BusScheduleTicket
  SET status = 'regular'
  WHERE status = 'booking'
    AND createdAt < SYSDATE - 7; 
END;




sqlplus hy/hy123@localhost:1521/xepdb1