DROP SEQUENCE PaymentID_seq;
DROP SEQUENCE PaymentID_seq;

CREATE SEQUENCE PaymentID_seq
MAXVALUE 999999999
START WITH 1
INCREMENT BY 1
NOCACHE;

CREATE SEQUENCE PointTxnID_seq
MAXVALUE 999999999
START WITH 1
INCREMENT BY 1
NOCACHE;

SET serveroutput on
SET linesize 120
SET pagesize 100

CREATE OR REPLACE PROCEDURE ProcessTicketRefund(
    p_ticketID   IN Ticket.ticketID%TYPE,
    p_refundType IN VARCHAR2, 
    p_adminID    IN VARCHAR2
    --p_result     OUT VARCHAR2
)
AS
    v_ticketStatus   Ticket.status%TYPE;
    v_paymentID      PaymentRecord.paymentID%TYPE;
    v_totalAmount    PaymentRecord.totalAmount%TYPE;
    v_pointsApplied  PaymentRecord.pointsApplied%TYPE;
    v_pointValue     PaymentRecord.pointValue%TYPE;
    v_customerID     Ticket.customerID%TYPE;
    v_refundAmount   NUMBER(8,2);
    v_daysBeforeDeparture NUMBER;
    v_departureTime  BusSchedule.plannedDepartureTime%TYPE;

    v_newPaymentID   VARCHAR2(12);
    v_newPointTxnID  VARCHAR2(12);
    v_result         VARCHAR2(100);
BEGIN
    -- Get ticket and payment details
    SELECT t.status,
        pr.paymentID,
        pr.totalAmount,
        pr.pointsApplied,
        pr.pointValue,
        t.customerID,
        bs.plannedDepartureTime
    INTO v_ticketStatus,
        v_paymentID,
        v_totalAmount,
        v_pointsApplied,
        v_pointValue,
        v_customerID,
        v_departureTime
    FROM Ticket t
    JOIN PaymentRecord pr 
        ON t.ticketID = pr.ticketID
    JOIN BusSchedule bs 
        ON t.busScheduleID = bs.busScheduleID
    WHERE t.ticketID = p_ticketID;


    -- Check if ticket can be refunded
    IF LOWER(v_ticketStatus) NOT IN ('cancelled_by_user', 'cancelled_by_company') THEN
        v_result := 'Error: Ticket is not cancelled';
        RETURN;
    END IF;

    -- Calculate days before departure
    v_daysBeforeDeparture := TRUNC(v_departureTime) - TRUNC(SYSDATE);

    -- Refund amount based on policy
    IF LOWER(p_refundType) = 'full' THEN
        v_refundAmount := v_totalAmount;
    ELSE
        IF v_daysBeforeDeparture > 7 THEN
            v_refundAmount := v_totalAmount * 0.8;
        ELSIF v_daysBeforeDeparture > 1 THEN
            v_refundAmount := v_totalAmount * 0.5;
        ELSE
            v_refundAmount := 0;
        END IF;
    END IF;

    -- Generate new IDs (use SEQUENCE in real system)
    SELECT 'RPY' || PaymentID_seq.NEXTVAL
    INTO v_newPaymentID
    FROM dual;
    
    SELECT 'RPT' || PointTxnID_seq.NEXTVAL
    INTO v_newPointTxnID
    FROM dual;

    -- Insert refund payment record
    INSERT INTO PaymentRecord (
        paymentID, customerID, ticketID, totalAmount, cashAmount,
        pointsApplied, pointValue, status, paymentTime,
        receiptNo, remarks, paymentMethod, type
    ) VALUES (
        v_newPaymentID, v_customerID, p_ticketID, v_refundAmount, v_refundAmount,
        0, 0, 'Completed', SYSDATE,
        'REF-' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '-' || p_ticketID,
        'Refund for ticket ' || p_ticketID || ' processed by admin ' || p_adminID,
        'Bank Transfer', 'Refund'
    );

    -- Return points if any were used
    IF v_pointsApplied > 0 THEN
        INSERT INTO PointTransaction (
            pointTxnID, customerID, paymentID, pointChange, source, remarks, createdAt
        ) VALUES (
            v_newPointTxnID, v_customerID, v_newPaymentID, v_pointsApplied,
            'Ticket Refund', 'Points returned for ticket ' || p_ticketID,
            SYSDATE
        );

        UPDATE Customer
        SET pointBalance = pointBalance + v_pointsApplied,
            updatedAt = SYSDATE
        WHERE customerID = v_customerID;
    END IF;

    v_result := 'Success: Refund processed for amount ' || v_refundAmount;
    COMMIT;
DBMS_OUTPUT.PUT_LINE(v_result);

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        v_result := 'Error: ' || SQLERRM;
END ProcessTicketRefund;
/



EXEC ProcessTicketRefund('T000001', 'partial', 'A123');


-- v_result     OUT VARCHAR2 : output the parameters
--user need to input the data of p_??? 
-- as is use to store the data 
-- when other : for example table is not found ,duplicate insertion or any compilation error
-- SQLERRM : return error message